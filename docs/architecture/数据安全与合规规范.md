# 数据安全与合规规范

## 1. 数据分类和保护等级

### 1.1 数据分类标准
```typescript
// apps/server/src/lib/data-classification.ts
export enum DataClassification {
  PUBLIC = 'public',           // 公开数据：股票代码、名称
  INTERNAL = 'internal',       // 内部数据：分析结果、策略模板
  CONFIDENTIAL = 'confidential', // 机密数据：用户策略、投资组合
  RESTRICTED = 'restricted'    // 受限数据：支付信息、个人身份信息
}

export const DATA_PROTECTION_LEVELS = {
  [DataClassification.PUBLIC]: {
    encryption: false,
    logging: 'basic',
    retention: '1 year',
    access: 'unrestricted'
  },
  [DataClassification.INTERNAL]: {
    encryption: 'at_rest',
    logging: 'detailed',
    retention: '2 years',
    access: 'authenticated'
  },
  [DataClassification.CONFIDENTIAL]: {
    encryption: 'at_rest_and_transit',
    logging: 'audit',
    retention: '7 years',
    access: 'owner_only'
  },
  [DataClassification.RESTRICTED]: {
    encryption: 'at_rest_and_transit_with_key_rotation',
    logging: 'full_audit',
    retention: '10 years_with_compliance',
    access: 'strict_rbac'
  }
} as const
```

## 2. 加密标准和实施

### 2.1 数据加密配置
```typescript
// apps/server/src/lib/encryption.ts
import { createCipher, createDecipher, randomBytes, pbkdf2Sync } from 'crypto'

interface EncryptionConfig {
  algorithm: string
  keyLength: number
  ivLength: number
  iterations: number
  saltLength: number
}

export const ENCRYPTION_STANDARDS = {
  AES_256_GCM: {
    algorithm: 'aes-256-gcm',
    keyLength: 32,
    ivLength: 16,
    iterations: 100000,
    saltLength: 16
  },
  AES_256_CBC: {
    algorithm: 'aes-256-cbc', 
    keyLength: 32,
    ivLength: 16,
    iterations: 100000,
    saltLength: 16
  }
} as const

export class DataEncryption {
  private static deriveKey(password: string, salt: Buffer, config: EncryptionConfig): Buffer {
    return pbkdf2Sync(password, salt, config.iterations, config.keyLength, 'sha256')
  }

  static encryptSensitiveData(data: string, masterKey: string): {
    encrypted: string
    salt: string
    iv: string
  } {
    const config = ENCRYPTION_STANDARDS.AES_256_GCM
    const salt = randomBytes(config.saltLength)
    const iv = randomBytes(config.ivLength)
    const key = this.deriveKey(masterKey, salt, config)
    
    const cipher = createCipher(config.algorithm, key)
    cipher.setAutoPadding(true)
    
    let encrypted = cipher.update(data, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    return {
      encrypted,
      salt: salt.toString('hex'),
      iv: iv.toString('hex')
    }
  }

  static decryptSensitiveData(
    encryptedData: { encrypted: string; salt: string; iv: string },
    masterKey: string
  ): string {
    const config = ENCRYPTION_STANDARDS.AES_256_GCM
    const salt = Buffer.from(encryptedData.salt, 'hex')
    const iv = Buffer.from(encryptedData.iv, 'hex')
    const key = this.deriveKey(masterKey, salt, config)
    
    const decipher = createDecipher(config.algorithm, key)
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}
```

### 2.2 API密钥管理
```typescript
// apps/server/src/lib/api-key-management.ts
export class ApiKeyManager {
  private static readonly KEY_PREFIX = 'nsk_'
  private static readonly KEY_ROTATION_DAYS = 90
  
  static async storeApiKey(
    service: string, 
    key: string, 
    classification: DataClassification
  ): Promise<void> {
    const encryptedKey = DataEncryption.encryptSensitiveData(
      key, 
      process.env.MASTER_ENCRYPTION_KEY!
    )
    
    await db.insert(apiKeys).values({
      service,
      keyHash: this.hashKey(key),
      encryptedKey: JSON.stringify(encryptedKey),
      classification,
      createdAt: new Date(),
      lastRotated: new Date(),
      rotationDue: new Date(Date.now() + this.KEY_ROTATION_DAYS * 24 * 60 * 60 * 1000)
    })

    // 审计日志
    await this.logKeyOperation('STORE', service, classification)
  }

  static async rotateApiKey(service: string): Promise<void> {
    const existingKey = await db
      .select()
      .from(apiKeys)
      .where(eq(apiKeys.service, service))
      .limit(1)

    if (existingKey.length === 0) {
      throw new Error(`No API key found for service: ${service}`)
    }

    // 生成新密钥
    const newKey = this.generateSecureKey()
    
    // 更新数据库
    await db
      .update(apiKeys)
      .set({
        keyHash: this.hashKey(newKey),
        encryptedKey: JSON.stringify(
          DataEncryption.encryptSensitiveData(newKey, process.env.MASTER_ENCRYPTION_KEY!)
        ),
        lastRotated: new Date(),
        rotationDue: new Date(Date.now() + this.KEY_ROTATION_DAYS * 24 * 60 * 60 * 1000)
      })
      .where(eq(apiKeys.service, service))

    await this.logKeyOperation('ROTATE', service, existingKey[0].classification)
  }

  private static hashKey(key: string): string {
    return createHash('sha256').update(key).digest('hex')
  }

  private static generateSecureKey(): string {
    return this.KEY_PREFIX + randomBytes(32).toString('hex')
  }

  private static async logKeyOperation(
    operation: string,
    service: string, 
    classification: DataClassification
  ): Promise<void> {
    await AuditLogger.log({
      operation,
      resource: 'api_key',
      service,
      classification,
      timestamp: new Date(),
      userId: 'system'
    })
  }
}
```

## 3. 审计日志系统

### 3.1 审计日志结构
```typescript
// apps/server/src/lib/audit-logger.ts
export interface AuditLogEntry {
  id: string
  timestamp: Date
  userId?: string
  sessionId?: string
  operation: string
  resource: string
  resourceId?: string
  classification: DataClassification
  ipAddress?: string
  userAgent?: string
  success: boolean
  errorMessage?: string
  metadata?: Record<string, any>
}

export class AuditLogger {
  static async log(entry: Omit<AuditLogEntry, 'id' | 'timestamp'>): Promise<void> {
    const logEntry: AuditLogEntry = {
      id: randomUUID(),
      timestamp: new Date(),
      ...entry
    }

    // 存储到数据库
    await db.insert(auditLogs).values(logEntry)

    // 高风险操作立即告警
    if (this.isHighRiskOperation(entry)) {
      await this.triggerSecurityAlert(logEntry)
    }

    // 实时日志流（生产环境发送到日志聚合服务）
    if (process.env.NODE_ENV === 'production') {
      await this.streamToLogAggregator(logEntry)
    }
  }

  static async logDataAccess(
    userId: string,
    dataType: string,
    dataId: string,
    operation: 'READ' | 'WRITE' | 'DELETE',
    classification: DataClassification
  ): Promise<void> {
    await this.log({
      userId,
      operation,
      resource: dataType,
      resourceId: dataId,
      classification,
      success: true,
      metadata: {
        accessType: 'data',
        sensitivityLevel: classification
      }
    })
  }

  static async logAuthEvent(
    userId: string,
    event: 'LOGIN' | 'LOGOUT' | 'LOGIN_FAILED',
    ipAddress: string,
    userAgent: string
  ): Promise<void> {
    await this.log({
      userId,
      operation: event,
      resource: 'authentication',
      classification: DataClassification.CONFIDENTIAL,
      ipAddress,
      userAgent,
      success: !event.includes('FAILED')
    })
  }

  private static isHighRiskOperation(entry: any): boolean {
    const highRiskPatterns = [
      'multiple_failed_logins',
      'admin_privilege_escalation',
      'bulk_data_export',
      'unauthorized_access_attempt'
    ]
    
    return highRiskPatterns.some(pattern => 
      entry.operation.toLowerCase().includes(pattern.toLowerCase())
    )
  }

  private static async triggerSecurityAlert(entry: AuditLogEntry): Promise<void> {
    // 发送安全告警到监控系统
    console.warn('SECURITY ALERT:', {
      operation: entry.operation,
      userId: entry.userId,
      timestamp: entry.timestamp,
      classification: entry.classification
    })
    
    // 生产环境发送到告警系统
    if (process.env.NODE_ENV === 'production') {
      // await SecurityAlertService.send(entry)
    }
  }
}
```

## 4. 数据保留和清理策略

### 4.1 数据保留政策
```typescript
// apps/server/src/lib/data-retention.ts
export interface RetentionPolicy {
  dataType: string
  classification: DataClassification
  retentionPeriodDays: number
  archiveAfterDays?: number
  anonymizeAfterDays?: number
  secureDeleteRequired: boolean
}

export const DATA_RETENTION_POLICIES: RetentionPolicy[] = [
  {
    dataType: 'user_sessions',
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriodDays: 30,
    secureDeleteRequired: true
  },
  {
    dataType: 'audit_logs',
    classification: DataClassification.RESTRICTED,
    retentionPeriodDays: 2555, // 7 years
    archiveAfterDays: 365,
    secureDeleteRequired: false
  },
  {
    dataType: 'user_strategies',
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriodDays: 2555, // 7 years
    anonymizeAfterDays: 1095, // 3 years
    secureDeleteRequired: true
  },
  {
    dataType: 'payment_data',
    classification: DataClassification.RESTRICTED,
    retentionPeriodDays: 3650, // 10 years (compliance requirement)
    anonymizeAfterDays: 365,
    secureDeleteRequired: true
  },
  {
    dataType: 'stock_market_data',
    classification: DataClassification.PUBLIC,
    retentionPeriodDays: 365,
    secureDeleteRequired: false
  }
]

export class DataRetentionService {
  static async applyRetentionPolicies(): Promise<void> {
    for (const policy of DATA_RETENTION_POLICIES) {
      await this.processRetentionPolicy(policy)
    }
  }

  private static async processRetentionPolicy(policy: RetentionPolicy): Promise<void> {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - policy.retentionPeriodDays)

    // 匿名化过期数据
    if (policy.anonymizeAfterDays) {
      const anonymizeDate = new Date()
      anonymizeDate.setDate(anonymizeDate.getDate() - policy.anonymizeAfterDays)
      
      await this.anonymizeData(policy.dataType, anonymizeDate)
    }

    // 归档数据
    if (policy.archiveAfterDays) {
      const archiveDate = new Date()
      archiveDate.setDate(archiveDate.getDate() - policy.archiveAfterDays)
      
      await this.archiveData(policy.dataType, archiveDate)
    }

    // 安全删除过期数据
    if (policy.secureDeleteRequired) {
      await this.secureDelete(policy.dataType, cutoffDate)
    } else {
      await this.standardDelete(policy.dataType, cutoffDate)
    }

    // 记录清理操作
    await AuditLogger.log({
      operation: 'DATA_RETENTION_CLEANUP',
      resource: policy.dataType,
      classification: policy.classification,
      success: true,
      metadata: {
        policy: policy,
        cutoffDate: cutoffDate
      }
    })
  }

  private static async secureDelete(dataType: string, beforeDate: Date): Promise<void> {
    // 实施安全删除（多次覆写）
    // 实际实现会根据具体的数据存储系统而不同
    console.log(`Secure delete ${dataType} before ${beforeDate}`)
  }
}
```

## 5. 合规性检查

### 5.1 合规性框架
```typescript
// apps/server/src/lib/compliance.ts
export enum ComplianceFramework {
  GDPR = 'gdpr',
  PCI_DSS = 'pci_dss', 
  SOX = 'sox',
  CHINA_CYBERSECURITY = 'china_cybersecurity'
}

export interface ComplianceRequirement {
  framework: ComplianceFramework
  requirement: string
  implementation: string
  status: 'implemented' | 'in_progress' | 'planned'
  lastAudit?: Date
  nextAudit: Date
}

export const COMPLIANCE_REQUIREMENTS: ComplianceRequirement[] = [
  {
    framework: ComplianceFramework.GDPR,
    requirement: 'Right to be forgotten (Article 17)',
    implementation: 'DataRetentionService.secureDelete + user data anonymization',
    status: 'implemented',
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.GDPR,
    requirement: 'Data breach notification (Article 33)',
    implementation: 'AuditLogger + SecurityAlertService < 72h notification',
    status: 'implemented', 
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.PCI_DSS,
    requirement: 'Encrypt transmission of cardholder data',
    implementation: 'TLS 1.3 + AES-256-GCM encryption',
    status: 'implemented',
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.CHINA_CYBERSECURITY,
    requirement: 'Data localization',
    implementation: 'All user data stored in China-based data centers',
    status: 'planned',
    nextAudit: new Date('2025-12-31')
  }
]
```

## 6. 安全监控和告警

### 6.1 异常检测
```typescript
// apps/server/src/lib/security-monitoring.ts
export class SecurityMonitoring {
  private static readonly SUSPICIOUS_PATTERNS = {
    MULTIPLE_FAILED_LOGINS: { threshold: 5, timeWindowMinutes: 15 },
    UNUSUAL_DATA_ACCESS: { threshold: 100, timeWindowMinutes: 60 },
    BULK_EXPORT: { threshold: 1000, timeWindowMinutes: 10 },
    OFF_HOURS_ACCESS: { startHour: 22, endHour: 6 }
  }

  static async detectAnomalies(): Promise<void> {
    await Promise.all([
      this.detectMultipleFailedLogins(),
      this.detectUnusualDataAccess(),
      this.detectBulkExport(),
      this.detectOffHoursAccess()
    ])
  }

  private static async detectMultipleFailedLogins(): Promise<void> {
    const pattern = this.SUSPICIOUS_PATTERNS.MULTIPLE_FAILED_LOGINS
    const timeWindow = new Date(Date.now() - pattern.timeWindowMinutes * 60 * 1000)

    const failedLogins = await db
      .select({ userId: auditLogs.userId, count: count() })
      .from(auditLogs)
      .where(
        and(
          eq(auditLogs.operation, 'LOGIN_FAILED'),
          gte(auditLogs.timestamp, timeWindow)
        )
      )
      .groupBy(auditLogs.userId)
      .having(gte(count(), pattern.threshold))

    for (const suspicious of failedLogins) {
      await this.triggerAlert({
        type: 'MULTIPLE_FAILED_LOGINS',
        userId: suspicious.userId,
        count: suspicious.count,
        timeWindow: pattern.timeWindowMinutes
      })
    }
  }

  private static async triggerAlert(alert: any): Promise<void> {
    await AuditLogger.log({
      operation: 'SECURITY_ALERT',
      resource: 'security_monitoring',
      classification: DataClassification.RESTRICTED,
      success: true,
      metadata: alert
    })

    // 发送告警通知
    console.warn('SECURITY ALERT:', alert)
  }
}
```

## 7. 实施检查清单

### 7.1 开发阶段
- [ ] 实施数据分类标准
- [ ] 配置加密服务
- [ ] 实现API密钥管理
- [ ] 建立审计日志系统
- [ ] 实施数据保留政策

### 7.2 测试阶段  
- [ ] 加密/解密功能测试
- [ ] 审计日志完整性测试
- [ ] 数据保留策略测试
- [ ] 合规性检查测试
- [ ] 安全监控测试

### 7.3 部署阶段
- [ ] 生产环境密钥配置
- [ ] 审计日志聚合配置
- [ ] 安全监控告警配置
- [ ] 合规性文档更新
- [ ] 安全培训和文档

## 8. 合规性认证目标

| 框架 | 状态 | 目标认证日期 | 负责人 |
|------|------|-------------|--------|
| GDPR合规 | 🟡 实施中 | 2025-12-31 | 安全团队 |
| PCI DSS Level 1 | 🟡 规划中 | 2026-06-30 | 安全团队 |
| ISO 27001 | 🟡 规划中 | 2026-12-31 | 合规团队 |
| 等保三级 | 🟡 规划中 | 2025-12-31 | 合规团队 |