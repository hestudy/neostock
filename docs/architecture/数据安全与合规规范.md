# æ•°æ®å®‰å…¨ä¸åˆè§„è§„èŒƒ

## 1. æ•°æ®åˆ†ç±»å’Œä¿æŠ¤ç­‰çº§

### 1.1 æ•°æ®åˆ†ç±»æ ‡å‡†
```typescript
// apps/server/src/lib/data-classification.ts
export enum DataClassification {
  PUBLIC = 'public',           // å…¬å¼€æ•°æ®ï¼šè‚¡ç¥¨ä»£ç ã€åç§°
  INTERNAL = 'internal',       // å†…éƒ¨æ•°æ®ï¼šåˆ†æç»“æœã€ç­–ç•¥æ¨¡æ¿
  CONFIDENTIAL = 'confidential', // æœºå¯†æ•°æ®ï¼šç”¨æˆ·ç­–ç•¥ã€æŠ•èµ„ç»„åˆ
  RESTRICTED = 'restricted'    // å—é™æ•°æ®ï¼šæ”¯ä»˜ä¿¡æ¯ã€ä¸ªäººèº«ä»½ä¿¡æ¯
}

export const DATA_PROTECTION_LEVELS = {
  [DataClassification.PUBLIC]: {
    encryption: false,
    logging: 'basic',
    retention: '1 year',
    access: 'unrestricted'
  },
  [DataClassification.INTERNAL]: {
    encryption: 'at_rest',
    logging: 'detailed',
    retention: '2 years',
    access: 'authenticated'
  },
  [DataClassification.CONFIDENTIAL]: {
    encryption: 'at_rest_and_transit',
    logging: 'audit',
    retention: '7 years',
    access: 'owner_only'
  },
  [DataClassification.RESTRICTED]: {
    encryption: 'at_rest_and_transit_with_key_rotation',
    logging: 'full_audit',
    retention: '10 years_with_compliance',
    access: 'strict_rbac'
  }
} as const
```

## 2. åŠ å¯†æ ‡å‡†å’Œå®æ–½

### 2.1 æ•°æ®åŠ å¯†é…ç½®
```typescript
// apps/server/src/lib/encryption.ts
import { createCipher, createDecipher, randomBytes, pbkdf2Sync } from 'crypto'

interface EncryptionConfig {
  algorithm: string
  keyLength: number
  ivLength: number
  iterations: number
  saltLength: number
}

export const ENCRYPTION_STANDARDS = {
  AES_256_GCM: {
    algorithm: 'aes-256-gcm',
    keyLength: 32,
    ivLength: 16,
    iterations: 100000,
    saltLength: 16
  },
  AES_256_CBC: {
    algorithm: 'aes-256-cbc', 
    keyLength: 32,
    ivLength: 16,
    iterations: 100000,
    saltLength: 16
  }
} as const

export class DataEncryption {
  private static deriveKey(password: string, salt: Buffer, config: EncryptionConfig): Buffer {
    return pbkdf2Sync(password, salt, config.iterations, config.keyLength, 'sha256')
  }

  static encryptSensitiveData(data: string, masterKey: string): {
    encrypted: string
    salt: string
    iv: string
  } {
    const config = ENCRYPTION_STANDARDS.AES_256_GCM
    const salt = randomBytes(config.saltLength)
    const iv = randomBytes(config.ivLength)
    const key = this.deriveKey(masterKey, salt, config)
    
    const cipher = createCipher(config.algorithm, key)
    cipher.setAutoPadding(true)
    
    let encrypted = cipher.update(data, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    return {
      encrypted,
      salt: salt.toString('hex'),
      iv: iv.toString('hex')
    }
  }

  static decryptSensitiveData(
    encryptedData: { encrypted: string; salt: string; iv: string },
    masterKey: string
  ): string {
    const config = ENCRYPTION_STANDARDS.AES_256_GCM
    const salt = Buffer.from(encryptedData.salt, 'hex')
    const iv = Buffer.from(encryptedData.iv, 'hex')
    const key = this.deriveKey(masterKey, salt, config)
    
    const decipher = createDecipher(config.algorithm, key)
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}
```

### 2.2 APIå¯†é’¥ç®¡ç†
```typescript
// apps/server/src/lib/api-key-management.ts
export class ApiKeyManager {
  private static readonly KEY_PREFIX = 'nsk_'
  private static readonly KEY_ROTATION_DAYS = 90
  
  static async storeApiKey(
    service: string, 
    key: string, 
    classification: DataClassification
  ): Promise<void> {
    const encryptedKey = DataEncryption.encryptSensitiveData(
      key, 
      process.env.MASTER_ENCRYPTION_KEY!
    )
    
    await db.insert(apiKeys).values({
      service,
      keyHash: this.hashKey(key),
      encryptedKey: JSON.stringify(encryptedKey),
      classification,
      createdAt: new Date(),
      lastRotated: new Date(),
      rotationDue: new Date(Date.now() + this.KEY_ROTATION_DAYS * 24 * 60 * 60 * 1000)
    })

    // å®¡è®¡æ—¥å¿—
    await this.logKeyOperation('STORE', service, classification)
  }

  static async rotateApiKey(service: string): Promise<void> {
    const existingKey = await db
      .select()
      .from(apiKeys)
      .where(eq(apiKeys.service, service))
      .limit(1)

    if (existingKey.length === 0) {
      throw new Error(`No API key found for service: ${service}`)
    }

    // ç”Ÿæˆæ–°å¯†é’¥
    const newKey = this.generateSecureKey()
    
    // æ›´æ–°æ•°æ®åº“
    await db
      .update(apiKeys)
      .set({
        keyHash: this.hashKey(newKey),
        encryptedKey: JSON.stringify(
          DataEncryption.encryptSensitiveData(newKey, process.env.MASTER_ENCRYPTION_KEY!)
        ),
        lastRotated: new Date(),
        rotationDue: new Date(Date.now() + this.KEY_ROTATION_DAYS * 24 * 60 * 60 * 1000)
      })
      .where(eq(apiKeys.service, service))

    await this.logKeyOperation('ROTATE', service, existingKey[0].classification)
  }

  private static hashKey(key: string): string {
    return createHash('sha256').update(key).digest('hex')
  }

  private static generateSecureKey(): string {
    return this.KEY_PREFIX + randomBytes(32).toString('hex')
  }

  private static async logKeyOperation(
    operation: string,
    service: string, 
    classification: DataClassification
  ): Promise<void> {
    await AuditLogger.log({
      operation,
      resource: 'api_key',
      service,
      classification,
      timestamp: new Date(),
      userId: 'system'
    })
  }
}
```

## 3. å®¡è®¡æ—¥å¿—ç³»ç»Ÿ

### 3.1 å®¡è®¡æ—¥å¿—ç»“æ„
```typescript
// apps/server/src/lib/audit-logger.ts
export interface AuditLogEntry {
  id: string
  timestamp: Date
  userId?: string
  sessionId?: string
  operation: string
  resource: string
  resourceId?: string
  classification: DataClassification
  ipAddress?: string
  userAgent?: string
  success: boolean
  errorMessage?: string
  metadata?: Record<string, any>
}

export class AuditLogger {
  static async log(entry: Omit<AuditLogEntry, 'id' | 'timestamp'>): Promise<void> {
    const logEntry: AuditLogEntry = {
      id: randomUUID(),
      timestamp: new Date(),
      ...entry
    }

    // å­˜å‚¨åˆ°æ•°æ®åº“
    await db.insert(auditLogs).values(logEntry)

    // é«˜é£é™©æ“ä½œç«‹å³å‘Šè­¦
    if (this.isHighRiskOperation(entry)) {
      await this.triggerSecurityAlert(logEntry)
    }

    // å®æ—¶æ—¥å¿—æµï¼ˆç”Ÿäº§ç¯å¢ƒå‘é€åˆ°æ—¥å¿—èšåˆæœåŠ¡ï¼‰
    if (process.env.NODE_ENV === 'production') {
      await this.streamToLogAggregator(logEntry)
    }
  }

  static async logDataAccess(
    userId: string,
    dataType: string,
    dataId: string,
    operation: 'READ' | 'WRITE' | 'DELETE',
    classification: DataClassification
  ): Promise<void> {
    await this.log({
      userId,
      operation,
      resource: dataType,
      resourceId: dataId,
      classification,
      success: true,
      metadata: {
        accessType: 'data',
        sensitivityLevel: classification
      }
    })
  }

  static async logAuthEvent(
    userId: string,
    event: 'LOGIN' | 'LOGOUT' | 'LOGIN_FAILED',
    ipAddress: string,
    userAgent: string
  ): Promise<void> {
    await this.log({
      userId,
      operation: event,
      resource: 'authentication',
      classification: DataClassification.CONFIDENTIAL,
      ipAddress,
      userAgent,
      success: !event.includes('FAILED')
    })
  }

  private static isHighRiskOperation(entry: any): boolean {
    const highRiskPatterns = [
      'multiple_failed_logins',
      'admin_privilege_escalation',
      'bulk_data_export',
      'unauthorized_access_attempt'
    ]
    
    return highRiskPatterns.some(pattern => 
      entry.operation.toLowerCase().includes(pattern.toLowerCase())
    )
  }

  private static async triggerSecurityAlert(entry: AuditLogEntry): Promise<void> {
    // å‘é€å®‰å…¨å‘Šè­¦åˆ°ç›‘æ§ç³»ç»Ÿ
    console.warn('SECURITY ALERT:', {
      operation: entry.operation,
      userId: entry.userId,
      timestamp: entry.timestamp,
      classification: entry.classification
    })
    
    // ç”Ÿäº§ç¯å¢ƒå‘é€åˆ°å‘Šè­¦ç³»ç»Ÿ
    if (process.env.NODE_ENV === 'production') {
      // await SecurityAlertService.send(entry)
    }
  }
}
```

## 4. æ•°æ®ä¿ç•™å’Œæ¸…ç†ç­–ç•¥

### 4.1 æ•°æ®ä¿ç•™æ”¿ç­–
```typescript
// apps/server/src/lib/data-retention.ts
export interface RetentionPolicy {
  dataType: string
  classification: DataClassification
  retentionPeriodDays: number
  archiveAfterDays?: number
  anonymizeAfterDays?: number
  secureDeleteRequired: boolean
}

export const DATA_RETENTION_POLICIES: RetentionPolicy[] = [
  {
    dataType: 'user_sessions',
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriodDays: 30,
    secureDeleteRequired: true
  },
  {
    dataType: 'audit_logs',
    classification: DataClassification.RESTRICTED,
    retentionPeriodDays: 2555, // 7 years
    archiveAfterDays: 365,
    secureDeleteRequired: false
  },
  {
    dataType: 'user_strategies',
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriodDays: 2555, // 7 years
    anonymizeAfterDays: 1095, // 3 years
    secureDeleteRequired: true
  },
  {
    dataType: 'payment_data',
    classification: DataClassification.RESTRICTED,
    retentionPeriodDays: 3650, // 10 years (compliance requirement)
    anonymizeAfterDays: 365,
    secureDeleteRequired: true
  },
  {
    dataType: 'stock_market_data',
    classification: DataClassification.PUBLIC,
    retentionPeriodDays: 365,
    secureDeleteRequired: false
  }
]

export class DataRetentionService {
  static async applyRetentionPolicies(): Promise<void> {
    for (const policy of DATA_RETENTION_POLICIES) {
      await this.processRetentionPolicy(policy)
    }
  }

  private static async processRetentionPolicy(policy: RetentionPolicy): Promise<void> {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - policy.retentionPeriodDays)

    // åŒ¿ååŒ–è¿‡æœŸæ•°æ®
    if (policy.anonymizeAfterDays) {
      const anonymizeDate = new Date()
      anonymizeDate.setDate(anonymizeDate.getDate() - policy.anonymizeAfterDays)
      
      await this.anonymizeData(policy.dataType, anonymizeDate)
    }

    // å½’æ¡£æ•°æ®
    if (policy.archiveAfterDays) {
      const archiveDate = new Date()
      archiveDate.setDate(archiveDate.getDate() - policy.archiveAfterDays)
      
      await this.archiveData(policy.dataType, archiveDate)
    }

    // å®‰å…¨åˆ é™¤è¿‡æœŸæ•°æ®
    if (policy.secureDeleteRequired) {
      await this.secureDelete(policy.dataType, cutoffDate)
    } else {
      await this.standardDelete(policy.dataType, cutoffDate)
    }

    // è®°å½•æ¸…ç†æ“ä½œ
    await AuditLogger.log({
      operation: 'DATA_RETENTION_CLEANUP',
      resource: policy.dataType,
      classification: policy.classification,
      success: true,
      metadata: {
        policy: policy,
        cutoffDate: cutoffDate
      }
    })
  }

  private static async secureDelete(dataType: string, beforeDate: Date): Promise<void> {
    // å®æ–½å®‰å…¨åˆ é™¤ï¼ˆå¤šæ¬¡è¦†å†™ï¼‰
    // å®é™…å®ç°ä¼šæ ¹æ®å…·ä½“çš„æ•°æ®å­˜å‚¨ç³»ç»Ÿè€Œä¸åŒ
    console.log(`Secure delete ${dataType} before ${beforeDate}`)
  }
}
```

## 5. åˆè§„æ€§æ£€æŸ¥

### 5.1 åˆè§„æ€§æ¡†æ¶
```typescript
// apps/server/src/lib/compliance.ts
export enum ComplianceFramework {
  GDPR = 'gdpr',
  PCI_DSS = 'pci_dss', 
  SOX = 'sox',
  CHINA_CYBERSECURITY = 'china_cybersecurity'
}

export interface ComplianceRequirement {
  framework: ComplianceFramework
  requirement: string
  implementation: string
  status: 'implemented' | 'in_progress' | 'planned'
  lastAudit?: Date
  nextAudit: Date
}

export const COMPLIANCE_REQUIREMENTS: ComplianceRequirement[] = [
  {
    framework: ComplianceFramework.GDPR,
    requirement: 'Right to be forgotten (Article 17)',
    implementation: 'DataRetentionService.secureDelete + user data anonymization',
    status: 'implemented',
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.GDPR,
    requirement: 'Data breach notification (Article 33)',
    implementation: 'AuditLogger + SecurityAlertService < 72h notification',
    status: 'implemented', 
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.PCI_DSS,
    requirement: 'Encrypt transmission of cardholder data',
    implementation: 'TLS 1.3 + AES-256-GCM encryption',
    status: 'implemented',
    nextAudit: new Date('2025-12-31')
  },
  {
    framework: ComplianceFramework.CHINA_CYBERSECURITY,
    requirement: 'Data localization',
    implementation: 'All user data stored in China-based data centers',
    status: 'planned',
    nextAudit: new Date('2025-12-31')
  }
]
```

## 6. å®‰å…¨ç›‘æ§å’Œå‘Šè­¦

### 6.1 å¼‚å¸¸æ£€æµ‹
```typescript
// apps/server/src/lib/security-monitoring.ts
export class SecurityMonitoring {
  private static readonly SUSPICIOUS_PATTERNS = {
    MULTIPLE_FAILED_LOGINS: { threshold: 5, timeWindowMinutes: 15 },
    UNUSUAL_DATA_ACCESS: { threshold: 100, timeWindowMinutes: 60 },
    BULK_EXPORT: { threshold: 1000, timeWindowMinutes: 10 },
    OFF_HOURS_ACCESS: { startHour: 22, endHour: 6 }
  }

  static async detectAnomalies(): Promise<void> {
    await Promise.all([
      this.detectMultipleFailedLogins(),
      this.detectUnusualDataAccess(),
      this.detectBulkExport(),
      this.detectOffHoursAccess()
    ])
  }

  private static async detectMultipleFailedLogins(): Promise<void> {
    const pattern = this.SUSPICIOUS_PATTERNS.MULTIPLE_FAILED_LOGINS
    const timeWindow = new Date(Date.now() - pattern.timeWindowMinutes * 60 * 1000)

    const failedLogins = await db
      .select({ userId: auditLogs.userId, count: count() })
      .from(auditLogs)
      .where(
        and(
          eq(auditLogs.operation, 'LOGIN_FAILED'),
          gte(auditLogs.timestamp, timeWindow)
        )
      )
      .groupBy(auditLogs.userId)
      .having(gte(count(), pattern.threshold))

    for (const suspicious of failedLogins) {
      await this.triggerAlert({
        type: 'MULTIPLE_FAILED_LOGINS',
        userId: suspicious.userId,
        count: suspicious.count,
        timeWindow: pattern.timeWindowMinutes
      })
    }
  }

  private static async triggerAlert(alert: any): Promise<void> {
    await AuditLogger.log({
      operation: 'SECURITY_ALERT',
      resource: 'security_monitoring',
      classification: DataClassification.RESTRICTED,
      success: true,
      metadata: alert
    })

    // å‘é€å‘Šè­¦é€šçŸ¥
    console.warn('SECURITY ALERT:', alert)
  }
}
```

## 7. å®æ–½æ£€æŸ¥æ¸…å•

### 7.1 å¼€å‘é˜¶æ®µ
- [ ] å®æ–½æ•°æ®åˆ†ç±»æ ‡å‡†
- [ ] é…ç½®åŠ å¯†æœåŠ¡
- [ ] å®ç°APIå¯†é’¥ç®¡ç†
- [ ] å»ºç«‹å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
- [ ] å®æ–½æ•°æ®ä¿ç•™æ”¿ç­–

### 7.2 æµ‹è¯•é˜¶æ®µ  
- [ ] åŠ å¯†/è§£å¯†åŠŸèƒ½æµ‹è¯•
- [ ] å®¡è®¡æ—¥å¿—å®Œæ•´æ€§æµ‹è¯•
- [ ] æ•°æ®ä¿ç•™ç­–ç•¥æµ‹è¯•
- [ ] åˆè§„æ€§æ£€æŸ¥æµ‹è¯•
- [ ] å®‰å…¨ç›‘æ§æµ‹è¯•

### 7.3 éƒ¨ç½²é˜¶æ®µ
- [ ] ç”Ÿäº§ç¯å¢ƒå¯†é’¥é…ç½®
- [ ] å®¡è®¡æ—¥å¿—èšåˆé…ç½®
- [ ] å®‰å…¨ç›‘æ§å‘Šè­¦é…ç½®
- [ ] åˆè§„æ€§æ–‡æ¡£æ›´æ–°
- [ ] å®‰å…¨åŸ¹è®­å’Œæ–‡æ¡£

## 8. åˆè§„æ€§è®¤è¯ç›®æ ‡

| æ¡†æ¶ | çŠ¶æ€ | ç›®æ ‡è®¤è¯æ—¥æœŸ | è´Ÿè´£äºº |
|------|------|-------------|--------|
| GDPRåˆè§„ | ğŸŸ¡ å®æ–½ä¸­ | 2025-12-31 | å®‰å…¨å›¢é˜Ÿ |
| PCI DSS Level 1 | ğŸŸ¡ è§„åˆ’ä¸­ | 2026-06-30 | å®‰å…¨å›¢é˜Ÿ |
| ISO 27001 | ğŸŸ¡ è§„åˆ’ä¸­ | 2026-12-31 | åˆè§„å›¢é˜Ÿ |
| ç­‰ä¿ä¸‰çº§ | ğŸŸ¡ è§„åˆ’ä¸­ | 2025-12-31 | åˆè§„å›¢é˜Ÿ |