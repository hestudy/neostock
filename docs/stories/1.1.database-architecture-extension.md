# Story 1.1: 数据库架构扩展和股票基础数据管理

## Status

Draft

## Story

**As a** 个人投资者，  
**I want** 系统能够存储和管理 A 股的基础信息和历史数据，  
**so that** 我可以查询和分析股票信息。

## Acceptance Criteria

1. **SQLite 架构优化** - 实现连接池管理(最大 10 个连接)，支持百人级并发访问，建立合理的索引策略，优化股票代码、名称、日期查询，实现查询性能优化，单次股票数据查询响应时间<200ms
2. **扩展 Drizzle schema** - 添加股票基础信息表（代码、名称、行业、上市日期等），创建日线数据表存储股价、成交量等交易数据，建立用户收藏股票关联表，实现完整的外键约束和数据一致性
3. **数据存储优化** - 实现数据压缩策略(SQLite PRAGMA 优化)，管理历史数据存储空间，建立数据清理机制，定期清理过期临时数据，实现数据分区逻辑，按时间范围优化查询性能
4. **详细迁移和回滚策略** - 为每个 schema 变更创建具体的 up/down 迁移脚本，实现迁移事务管理和原子性操作，建立迁移前数据完整性验证，配置自动回滚触发器(迁移失败>3 次)，实现迁移状态跟踪和日志记录
5. **兼容性保证强化** - 保持与现有用户认证表的 100%兼容性，实现数据库 schema 版本管理，建立迁移测试环境验证，支持现有数据无缝升级(零停机时间)
6. **扩展性和监控** - 建立数据库抽象层，为未来可能的数据库迁移做准备，实现配置化的数据库连接管理，添加迁移性能监控和告警，建立数据库健康检查端点

## Tasks / Subtasks

**⚠️ 执行顺序说明：任务按序号顺序执行，任务间存在依赖关系，必须严格遵守执行顺序**

### Phase 1: 基础架构准备 (依赖：无)

- [ ] **Task 1**: 设计股票相关数据库表结构 (AC: 2) 
  - [ ] 1.1 创建股票基础信息表 (stocks) - 代码、名称、行业、上市日期等
  - [ ] 1.2 创建日线数据表 (stock_daily) - OHLCV 数据、成交量等  
  - [ ] 1.3 创建用户收藏股票关联表 (user_stock_favorites)
  - [ ] 1.4 定义完整的外键约束和索引策略
  
- [ ] **Task 2**: 实现 SQLite 架构优化 (AC: 1) **[依赖: Task 1 完成]**
  - [ ] 2.1 配置连接池管理器，最大 10 个连接
  - [ ] 2.2 建立索引策略：股票代码、名称、日期字段优化
  - [ ] 2.3 实现查询性能监控，目标单次查询<200ms
  - [ ] 2.4 配置百人级并发支持

### Phase 2: 数据库迁移系统 (依赖：Phase 1 完成)

- [ ] **Task 3**: 创建数据库迁移系统增强 (AC: 4) **[依赖: Task 1, 2 完成]**
  - [ ] 3.1 为新表创建 up/down 迁移脚本
  - [ ] 3.2 实现迁移事务管理和原子性操作
  - [ ] 3.3 建立迁移前数据完整性验证
  - [ ] 3.4 配置自动回滚触发器(失败>3次)
  - [ ] 3.5 实现迁移状态跟踪和日志记录

- [ ] **Task 4**: 确保兼容性保证 (AC: 5) **[依赖: Task 3 完成]**
  - [ ] 4.1 验证现有认证表 100%兼容性
  - [ ] 4.2 实现数据库 schema 版本管理
  - [ ] 4.3 建立迁移测试环境
  - [ ] 4.4 实现零停机升级策略

### Phase 3: 优化和监控 (依赖：Phase 2 完成)

- [ ] **Task 5**: 实现数据存储优化 (AC: 3) **[依赖: Task 3, 4 完成]**
  - [ ] 5.1 配置 SQLite PRAGMA 优化策略
  - [ ] 5.2 建立历史数据管理机制
  - [ ] 5.3 实现数据清理策略，清理过期临时数据
  - [ ] 5.4 实现数据分区逻辑，按时间范围优化查询

- [ ] **Task 6**: 建立扩展性和监控系统 (AC: 6) **[依赖: Task 5 完成]**
  - [ ] 6.1 创建数据库抽象层
  - [ ] 6.2 实现配置化的数据库连接管理
  - [ ] 6.3 添加迁移性能监控和告警
  - [ ] 6.4 建立数据库健康检查端点
  - [ ] 6.5 响应时间监控：API 响应时间 <200ms，超过阈值触发告警
  - [ ] 6.6 连接池监控：每 30 秒检查连接池状态，可用连接数 <2 时告警
  - [ ] 6.7 数据库性能监控：每 5 分钟采集慢查询日志 (>100ms)
  - [ ] 6.8 磁盘空间监控：数据库文件大小增长率，每日增长 >10% 预警
  - [ ] 6.9 实施详细的SLA监控和告警系统
  - [ ] 6.10 建立业务指标监控和异常检测

### 关键依赖关系说明

- **Phase 1 → Phase 2**: 必须先完成数据库表设计和基础架构优化，才能进行迁移系统开发
- **Task 3 → Task 4**: 迁移系统必须先实现，才能测试兼容性保证
- **Task 4 → Task 5**: 兼容性验证通过后，才能进行存储优化
- **Task 5 → Task 6**: 存储优化完成后，最后建立监控系统
- **关键阻塞点**: 如果 Task 3 (迁移系统) 失败，后续所有任务都会被阻塞

## Testing

### 测试框架和标准

**测试技术栈**：

- **后端测试**: Bun:test + Vitest
- **数据库测试**: 内存数据库 (`:memory:`) 进行快速测试
- **覆盖率要求**: 数据库操作 >90%，总体覆盖率 >80%
- **测试工具**: @vitest/coverage-v8

### 测试文件位置

基于测试策略 [Source: docs/testing-strategy.md]：

- **数据库测试**: `apps/server/src/__tests__/db/`
- **API测试**: `apps/server/src/__tests__/routers/`
- **集成测试**: `apps/server/src/__tests__/integration/`

### 核心测试要求

#### 1. Schema 测试

**测试文件**: `apps/server/src/__tests__/db/schema/stocks.test.ts`

- 验证新表结构定义正确性
- 测试外键约束和索引有效性
- 验证数据类型和长度限制
- **Mock 数据规格**:
  - 股票基础数据: 最少 100 条 A 股样本数据，覆盖不同行业和市场类型
  - 日线数据: 每个测试股票至少包含 30 天历史数据
  - 用户收藏: 模拟 10 个用户各收藏 5-20 只股票的测试场景

#### 2. 迁移测试

**测试文件**: `apps/server/src/__tests__/db/migrations/002_v1.1_stocks.test.ts`

- 测试 up 迁移成功创建新表
- 测试 down 迁移正确回滚
- 验证迁移事务管理和原子性
- 测试迁移状态跟踪和日志记录
- **扩展测试场景**:
  - 模拟迁移中断场景 (网络断开、系统重启)
  - 测试并发迁移冲突处理
  - 验证大数据量迁移性能 (1万条股票 + 100万条日线数据)

#### 3. 性能测试

**测试文件**: `apps/server/src/__tests__/performance/database.test.ts`

- 验证百人级并发访问性能
- 测试单次查询响应时间 <200ms
- 验证连接池管理有效性
- 测试种子数据导入性能 <5分钟
- **具体测试场景**:
  - 100 并发用户同时查询不同股票信息
  - 复杂条件搜索测试 (行业 + 关键词 + 日期范围)
  - 收藏股票列表聚合查询性能测试
  - 历史数据时间序列查询性能验证

#### 4. 兼容性测试

**测试文件**: `apps/server/src/__tests__/integration/compatibility.test.ts`

- 验证现有认证功能不受影响
- 测试数据迁移零停机升级
- 验证现有用户数据完整性
- **边缘情况测试**:
  - 现有用户登录后立即使用新功能
  - 迁移过程中的用户会话保持
  - 新旧 schema 版本并存兼容性

#### 5. API 集成测试

**测试文件**: `apps/server/src/__tests__/routers/stocks.test.ts`

- 测试新 API 端点与 tRPC 路由体系兼容性
- 验证端到端类型安全
- 测试用户权限控制
- **端到端测试场景**:
  - 用户注册 → 登录 → 搜索股票 → 添加收藏 → 查看收藏列表
  - 股票数据更新 → 用户查询最新数据 → 数据一致性验证
  - API 错误处理 → 前端友好错误提示 → 用户体验验证

### 测试数据管理

#### Mock 数据生成

```typescript
// apps/server/src/__tests__/helpers/mock-stock-data.ts
export const generateMockStocks = (count: number) => {
  // 生成包含不同行业、市场类型的测试股票数据
};

export const generateMockDailyData = (stockCode: string, days: number) => {
  // 生成指定股票的历史交易数据
};
```

#### 测试环境配置

- 使用独立的测试数据库实例
- 每个测试套件前后自动清理数据
- 并行测试隔离，避免数据冲突

### 质量门控集成

**必须通过的测试检查**：

- 所有单元测试通过率 100%
- 代码覆盖率 >90% (数据库层)
- 性能测试达标 (查询<200ms, 并发支持100用户)
- 兼容性测试零失败
- Mock数据完整性验证通过

## Dev Notes

### 前一个故事的洞察

基于 Story 1.0 的完成记录，数据库迁移系统已经建立，但仅支持基础的迁移管理。当前系统具备：

- 基础迁移框架 (migrator.ts)
- 事务管理和回滚机制
- 完善的测试覆盖 (387行安全测试代码)
- 质量门控检查通过

### 数据模型

当前数据库结构 [Source: apps/server/src/db/schema/auth.ts]：

```typescript
// 现有认证相关表
- user: 用户基本信息 (id, name, email, emailVerified, image, createdAt, updatedAt)
- session: 用户会话管理 (id, expiresAt, token, userId, ipAddress, userAgent)
- account: 第三方账户关联，支持多种认证提供商
- verification: 验证码和令牌管理
```

需要新增的股票相关表结构：

```typescript
// 股票基础信息表
interface StockBasicInfo {
  ts_code: string; // 股票代码 (如: "000001.SZ")
  symbol: string; // 股票符号
  name: string; // 股票名称
  area: string; // 地域
  industry: string; // 所属行业
  market: string; // 市场类型 (主板/创业板)
  list_date: string; // 上市日期 (YYYYMMDD格式)
  is_hs: string; // 是否沪深港通标的
}

// 日线数据表
interface StockDailyData {
  id: number;
  ts_code: string; // 股票代码
  trade_date: string; // 交易日期
  open: number; // 开盘价
  high: number; // 最高价
  low: number; // 最低价
  close: number; // 收盘价
  vol: number; // 成交量
  amount: number; // 成交额
}

// 用户收藏股票关联表
interface UserStockFavorite {
  id: number;
  user_id: string; // 外键关联 user.id
  ts_code: string; // 外键关联 stocks.ts_code
  created_at: number; // 收藏时间戳
}
```

### API 规范

需要扩展的 tRPC API 端点 [Source: docs/architecture/数据模型和-api.md#api-规范]：

```typescript
// 股票查询相关端点
- getStockList: 获取股票列表，支持分页和搜索
- getStockDetail: 获取单个股票详细信息
- getStockDailyData: 获取股票历史交易数据
- getUserFavorites: 获取用户收藏的股票列表
- addToFavorites: 添加股票到收藏
- removeFromFavorites: 从收藏中移除股票
```

### 文件位置

基于项目结构 [Source: docs/architecture/源码树和模块组织.md#项目结构实际]：

#### 数据库相关文件

- 新增 schema: `apps/server/src/db/schema/stocks.ts`
- 新增迁移: `apps/server/src/db/migrations/002_v1.1_create_stocks_tables.ts`
- 数据库配置: `apps/server/drizzle.config.ts` (已存在)
- 连接管理: `apps/server/src/db/index.ts` (需要更新)

#### API 相关文件

- 新增路由: `apps/server/src/routers/stocks.ts`
- 更新根路由: `apps/server/src/routers/index.ts`
- 类型定义: `apps/server/src/types/stocks.ts`

#### 测试文件

- Schema 测试: `apps/server/src/__tests__/db/schema/stocks.test.ts`
- 迁移测试: `apps/server/src/__tests__/db/migrations/002_v1.1_stocks.test.ts`
- API 测试: `apps/server/src/__tests__/routers/stocks.test.ts`

### 技术约束

[Source: docs/architecture/高级架构.md#实际技术栈]

- **数据库**: SQLite/Turso + Drizzle ORM v0.44.2
- **运行时**: Bun 1.2.18
- **数据库客户端**: @libsql/client v0.15.9
- **兼容性**: 必须保持现有 Better Auth 认证功能 100% 兼容

### 性能要求

[Source: ADR-001: SQLite优化策略]

- **并发支持**: 连接池管理，最大 10 个连接
- **查询性能**: 单次股票数据查询响应时间 <200ms
- **并发目标**: 支持百人级并发访问
- **索引优化**: 股票代码、名称、日期字段建立复合索引

### 数据库优化配置

SQLite PRAGMA 优化策略：

```sql
PRAGMA journal_mode = WAL;           -- Write-Ahead Logging
PRAGMA synchronous = NORMAL;         -- 平衡性能和安全
PRAGMA cache_size = -64000;          -- 64MB缓存
PRAGMA temp_store = MEMORY;          -- 临时数据内存存储
PRAGMA mmap_size = 268435456;        -- 256MB内存映射
```

### 种子数据要求

[Source: apps/server/src/lib/seed-data.ts]

- **数据规模**: 4000 只 A 股股票
- **导入性能**: <5 分钟完成
- **批处理**: 1000 条/批次
- **数据验证**: 100% 完整性检查
- **错误处理**: 完整的重试和回滚机制

#### 种子数据格式规范

1. **股票基础数据格式 (CSV/JSON)**

   ```json
   // apps/server/data/seeds/stocks_basic.json
   [
     {
       "ts_code": "000001.SZ",      // 必需：6位数字+.SZ/.SH
       "symbol": "000001",          // 必需：6位股票代码
       "name": "平安银行",           // 必需：1-20字符中文股票名称
       "area": "深圳",              // 可选：地域信息
       "industry": "银行",          // 必需：所属行业分类
       "market": "主板",            // 必需：主板/创业板/科创板/北交所
       "list_date": "19910403",     // 必需：YYYYMMDD格式上市日期
       "is_hs": "1"                 // 必需：是否沪深港通标的 (1=是, 0=否)
     }
   ]
   ```

2. **数据字段验证规则**

   ```typescript
   // apps/server/src/lib/seed-validators.ts
   import { z } from "zod";

   export const StockBasicDataSchema = z.object({
     ts_code: z.string()
       .regex(/^[0-9]{6}\.(SH|SZ)$/, "股票代码格式错误")
       .refine((code) => {
         const market = code.split('.')[1];
         const number = code.split('.')[0];
         // 验证编码规则：沪市60/68/90开头，深市00/30/20开头
         if (market === 'SH') return ['60', '68', '90'].includes(number.slice(0, 2));
         if (market === 'SZ') return ['00', '30', '20'].includes(number.slice(0, 2));
         return false;
       }, "股票代码与市场不匹配"),
     
     symbol: z.string()
       .regex(/^[0-9]{6}$/, "股票符号必须是6位数字"),
     
     name: z.string()
       .min(1, "股票名称不能为空")
       .max(20, "股票名称不超过20字符")
       .regex(/^[\u4e00-\u9fa5A-Z0-9*ST]+$/, "股票名称只能包含中文、大写字母、数字"),
     
     area: z.string().max(10).optional(),
     
     industry: z.string()
       .min(1, "行业分类不能为空")
       .max(20, "行业分类不超过20字符")
       .refine((industry) => {
         // 验证行业分类是否在预定义列表中
         const validIndustries = [
           "银行", "保险", "证券", "房地产", "建筑", "钢铁", "煤炭",
           "有色金属", "化工", "石化", "电力", "汽车", "机械", "电子",
           "计算机", "通信", "医药", "食品饮料", "纺织服装", "轻工制造"
         ];
         return validIndustries.includes(industry);
       }, "无效的行业分类"),
     
     market: z.enum(["主板", "创业板", "科创板", "北交所"], {
       errorMap: () => ({ message: "无效的市场类型" })
     }),
     
     list_date: z.string()
       .regex(/^[0-9]{8}$/, "上市日期格式错误，应为YYYYMMDD")
       .refine((date) => {
         const year = parseInt(date.slice(0, 4));
         const month = parseInt(date.slice(4, 6));
         const day = parseInt(date.slice(6, 8));
         
         // 验证日期有效性
         if (year < 1990 || year > new Date().getFullYear()) return false;
         if (month < 1 || month > 12) return false;
         if (day < 1 || day > 31) return false;
         
         // 验证是否为工作日（简单检查）
         const dateObj = new Date(year, month - 1, day);
         return !isNaN(dateObj.getTime());
       }, "无效的上市日期"),
     
     is_hs: z.enum(["0", "1"], {
       errorMap: () => ({ message: "沪深港通标识只能是0或1" })
     })
   });

   export const validateStockBatch = (stocks: unknown[]): StockBasicData[] => {
     const validatedStocks = stocks.map((stock, index) => {
       try {
         return StockBasicDataSchema.parse(stock);
       } catch (error) {
         throw new Error(`第${index + 1}条股票数据验证失败: ${error.message}`);
       }
     });

     // 检查重复的股票代码
     const codes = validatedStocks.map(s => s.ts_code);
     const duplicates = codes.filter((code, index) => codes.indexOf(code) !== index);
     if (duplicates.length > 0) {
       throw new Error(`发现重复的股票代码: ${duplicates.join(', ')}`);
     }

     return validatedStocks;
   };
   ```

3. **种子数据来源和更新策略**

   ```typescript
   // apps/server/src/lib/seed-data-manager.ts
   export class SeedDataManager {
     private readonly dataSources = {
       primary: "tushare",          // 主数据源：Tushare API
       backup: "eastmoney",         // 备用数据源：东方财富
       manual: "manual_import"      // 手动导入数据
     };

     async updateSeedData(source: keyof typeof this.dataSources = "primary") {
       const timestamp = Date.now();
       const backupPath = `data/backups/stocks_${timestamp}.json`;
       
       try {
         // 1. 备份现有数据
         await this.backupCurrentData(backupPath);
         
         // 2. 获取最新数据
         const latestData = await this.fetchLatestStockData(source);
         
         // 3. 数据验证和清理
         const validatedData = await this.validateAndCleanData(latestData);
         
         // 4. 增量更新检查
         const changes = await this.detectChanges(validatedData);
         
         // 5. 执行更新
         if (changes.length > 0) {
           await this.applyChanges(changes);
           console.log(`更新完成: 新增${changes.filter(c => c.type === 'INSERT').length}只股票`);
           console.log(`更新完成: 修改${changes.filter(c => c.type === 'UPDATE').length}只股票`);
           console.log(`更新完成: 退市${changes.filter(c => c.type === 'DELETE').length}只股票`);
         }
         
       } catch (error) {
         // 回滚到备份数据
         await this.rollbackFromBackup(backupPath);
         throw error;
       }
     }

     // 数据完整性检查
     async validateDataIntegrity(): Promise<IntegrityReport> {
       const checks = [
         this.checkDuplicateCodes(),
         this.checkMissingRequiredFields(), 
         this.checkDataConsistency(),
         this.checkIndustryClassification(),
         this.checkMarketSegmentation()
       ];

       const results = await Promise.all(checks);
       return {
         isValid: results.every(r => r.passed),
         checks: results,
         timestamp: Date.now()
       };
     }
   }

   // 数据更新频率配置
   export const seedDataConfig = {
     updateSchedule: {
       daily: "0 6 * * *",          // 每日6点更新基础信息
       weekly: "0 2 * * 0",         // 每周日2点全量检查
       monthly: "0 1 1 * *"         // 每月1号深度验证
     },
     
     batchSize: 1000,               // 批处理大小
     maxRetries: 3,                 // 最大重试次数
     timeoutMs: 30000,              // 单批次超时时间
     
     dataQuality: {
       minCompleteness: 0.95,       // 数据完整度要求95%
       maxErrorRate: 0.01,          // 错误率不超过1%
       requiredFields: ["ts_code", "name", "industry", "market", "list_date"]
     }
   };
   ```

4. **种子数据导入命令和脚本**

   ```bash
   # apps/server/scripts/seed-data.sh
   #!/bin/bash
   
   echo "开始导入股票种子数据..."
   
   # 检查数据文件是否存在
   if [ ! -f "data/seeds/stocks_basic.json" ]; then
     echo "错误: 种子数据文件不存在"
     exit 1
   fi
   
   # 验证JSON格式
   bun run scripts/validate-seed-data.ts
   if [ $? -ne 0 ]; then
     echo "错误: 种子数据格式验证失败"
     exit 1
   fi
   
   # 备份现有数据
   timestamp=$(date +%Y%m%d_%H%M%S)
   mkdir -p data/backups
   sqlite3 local.db ".backup data/backups/pre_seed_${timestamp}.db"
   
   # 执行导入
   bun run scripts/import-seed-data.ts --file=data/seeds/stocks_basic.json --batch-size=1000
   
   # 验证导入结果
   bun run scripts/verify-seed-import.ts
   
   echo "种子数据导入完成"
   ```

   ```typescript
   // apps/server/scripts/import-seed-data.ts
   import { db } from "../src/db";
   import { stocks } from "../src/db/schema/stocks";
   import { SeedDataManager, validateStockBatch } from "../src/lib/seed-data-manager";

   async function importSeedData(filePath: string, batchSize: number = 1000) {
     const manager = new SeedDataManager();
     
     // 读取和验证数据
     const rawData = await Bun.file(filePath).json();
     const validatedData = validateStockBatch(rawData);
     
     console.log(`准备导入 ${validatedData.length} 只股票数据`);
     
     // 批量导入
     const batches = [];
     for (let i = 0; i < validatedData.length; i += batchSize) {
       batches.push(validatedData.slice(i, i + batchSize));
     }
     
     let importedCount = 0;
     for (const [index, batch] of batches.entries()) {
       try {
         await db.transaction(async (tx) => {
           await tx.insert(stocks).values(
             batch.map(stock => ({
               ...stock,
               created_at: Date.now(),
               updated_at: Date.now()
             }))
           );
         });
         
         importedCount += batch.length;
         console.log(`批次 ${index + 1}/${batches.length} 完成，已导入 ${importedCount} 只股票`);
         
         // 进度报告
         if (index % 5 === 0) {
           const progress = ((index + 1) / batches.length * 100).toFixed(1);
           console.log(`导入进度: ${progress}%`);
         }
         
       } catch (error) {
         console.error(`批次 ${index + 1} 导入失败:`, error);
         throw error;
       }
     }
     
     // 最终验证
     const integrityReport = await manager.validateDataIntegrity();
     if (!integrityReport.isValid) {
       throw new Error("数据完整性验证失败");
     }
     
     console.log(`种子数据导入成功: ${importedCount} 只股票`);
   }

   // 命令行参数解析
   const args = process.argv.slice(2);
   const fileArg = args.find(arg => arg.startsWith('--file='));
   const batchArg = args.find(arg => arg.startsWith('--batch-size='));
   
   const filePath = fileArg?.split('=')[1] || 'data/seeds/stocks_basic.json';
   const batchSize = parseInt(batchArg?.split('=')[1] || '1000');
   
   importSeedData(filePath, batchSize).catch(console.error);
   ```

### 数据库备份和恢复策略

#### 备份操作详细步骤

1. **定时备份配置**

   ```bash
   # 每日凌晨 2:00 自动备份
   0 2 * * * /opt/neostock/scripts/db-backup.sh
   ```

2. **手动备份操作**

   ```bash
   cd apps/server
   # SQLite 数据库备份
   sqlite3 local.db ".backup backup/$(date +%Y%m%d_%H%M%S)_neostock.db"
   # 压缩备份文件
   gzip backup/$(date +%Y%m%d_%H%M%S)_neostock.db
   ```

3. **备份验证流程**
   - 备份完成后自动验证文件完整性 (MD5 校验)
   - 每周随机抽取一个备份进行恢复测试
   - 备份元数据记录 (大小、时间戳、schema 版本)

#### 恢复操作详细步骤

1. **紧急恢复流程**

   ```bash
   # 停止应用服务
   systemctl stop neostock-server
   # 备份当前损坏数据库 (如果可能)
   cp local.db local.db.corrupted.$(date +%Y%m%d_%H%M%S)
   # 从备份恢复
   gunzip -c backup/20250825_020000_neostock.db.gz > local.db
   # 验证恢复后数据完整性
   bun run db:validate
   # 重启服务
   systemctl start neostock-server
   ```

2. **增量恢复机制**
   - WAL 文件保留策略 (保留最近 7 天)
   - 支持基于时间点的恢复 (PITR)
   - 恢复过程事务日志记录

3. **灾难恢复测试**
   - 月度恢复演练
   - RTO 目标: <1 小时
   - RPO 目标: <15 分钟数据丢失

### 测试

#### 测试文件位置

基于测试策略 [Source: docs/testing-strategy.md]：

- 数据库测试: `apps/server/src/__tests__/db/`
- API 测试: `apps/server/src/__tests__/routers/`
- 集成测试: `apps/server/src/__tests__/integration/`

#### 测试框架和模式

- **后端测试**: Bun:test + Vitest
- **数据库测试**: 内存数据库 (`:memory:`) 进行快速测试
- **覆盖率目标**: 数据库操作 >90%
- **测试工具**: @vitest/coverage-v8

#### 本故事特定测试要求

1. **Schema 测试**
   - 验证新表结构定义正确性
   - 测试外键约束和索引有效性
   - 验证数据类型和长度限制
   - **Mock 数据规格**:
     - 股票基础数据: 最少 100 条 A 股样本数据，覆盖不同行业和市场类型
     - 日线数据: 每个测试股票至少包含 30 天历史数据
     - 用户收藏: 模拟 10 个用户各收藏 5-20 只股票的测试场景

2. **迁移测试**
   - 测试 up 迁移成功创建新表
   - 测试 down 迁移正确回滚
   - 验证迁移事务管理和原子性
   - 测试迁移状态跟踪和日志记录
   - **测试场景扩展**:
     - 模拟迁移中断场景 (网络断开、系统重启)
     - 测试并发迁移冲突处理
     - 验证大数据量迁移性能 (1万条股票 + 100万条日线数据)

3. **性能测试**
   - 验证百人级并发访问性能
   - 测试单次查询响应时间 <200ms
   - 验证连接池管理有效性
   - 测试种子数据导入性能 <5分钟
   - **具体测试场景**:
     - 100 并发用户同时查询不同股票信息
     - 复杂条件搜索测试 (行业 + 关键词 + 日期范围)
     - 收藏股票列表聚合查询性能测试
     - 历史数据时间序列查询性能验证

4. **兼容性测试**
   - 验证现有认证功能不受影响
   - 测试数据迁移零停机升级
   - 验证现有用户数据完整性
   - **边缘情况测试**:
     - 现有用户登录后立即使用新功能
     - 迁移过程中的用户会话保持
     - 新旧 schema 版本并存兼容性

5. **集成测试**
   - 测试新 API 端点与 tRPC 路由体系兼容性
   - 验证端到端类型安全
   - 测试用户权限控制
   - **端到端测试场景**:
     - 用户注册 → 登录 → 搜索股票 → 添加收藏 → 查看收藏列表
     - 股票数据更新 → 用户查询最新数据 → 数据一致性验证
     - API 错误处理 → 前端友好错误提示 → 用户体验验证

### 任务执行顺序验证

**开发代理必须按以下顺序执行任务，并在每个 Phase 完成后进行验证：**

1. **Phase 1 验证点**: 完成 Task 1-2 后，验证数据库表创建成功且连接池正常工作
2. **Phase 2 验证点**: 完成 Task 3-4 后，验证迁移系统可以成功回滚，且现有功能不受影响  
3. **Phase 3 验证点**: 完成 Task 5-6 后，验证所有性能指标满足要求，监控系统正常工作

### 具体实现指导

#### Drizzle Schema 定义示例

```typescript
// apps/server/src/db/schema/stocks.ts
import {
  sqliteTable,
  text,
  integer,
  real,
  primaryKey,
} from "drizzle-orm/sqlite-core";
import { relations } from "drizzle-orm";
import { user } from "./auth";

export const stocks = sqliteTable("stocks", {
  ts_code: text("ts_code").primaryKey(),
  symbol: text("symbol").notNull(),
  name: text("name").notNull(),
  area: text("area"),
  industry: text("industry"),
  market: text("market"),
  list_date: text("list_date"),
  is_hs: text("is_hs"),
  created_at: integer("created_at").notNull(),
  updated_at: integer("updated_at").notNull(),
});

export const stock_daily = sqliteTable("stock_daily", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  ts_code: text("ts_code")
    .references(() => stocks.ts_code, { onDelete: "cascade", onUpdate: "cascade" })
    .notNull(),
  trade_date: text("trade_date").notNull(),
  open: real("open").notNull(),
  high: real("high").notNull(),
  low: real("low").notNull(),
  close: real("close").notNull(),
  vol: real("vol").default(0),
  amount: real("amount").default(0),
  created_at: integer("created_at").notNull(),
}, (table) => ({
  // 复合索引：股票代码 + 交易日期的唯一约束
  stockDateIdx: uniqueIndex("stock_daily_ts_code_trade_date_idx").on(table.ts_code, table.trade_date),
  // 查询优化索引
  tradeDateIdx: index("stock_daily_trade_date_idx").on(table.trade_date),
  tsCodeIdx: index("stock_daily_ts_code_idx").on(table.ts_code),
}));

export const user_stock_favorites = sqliteTable(
  "user_stock_favorites",
  {
    id: integer("id").primaryKey({ autoIncrement: true }),
    user_id: text("user_id")
      .references(() => user.id, { onDelete: "cascade", onUpdate: "cascade" })
      .notNull(),
    ts_code: text("ts_code")
      .references(() => stocks.ts_code, { onDelete: "cascade", onUpdate: "cascade" })
      .notNull(),
    created_at: integer("created_at").notNull(),
  },
  (table) => ({
    // 用户-股票的唯一组合约束
    userStockUnique: uniqueIndex("user_stock_favorites_user_ts_code_idx").on(table.user_id, table.ts_code),
    // 查询优化索引
    userIdIdx: index("user_stock_favorites_user_id_idx").on(table.user_id),
    tsCodeIdx: index("user_stock_favorites_ts_code_idx").on(table.ts_code),
  })
);

// 关系定义（用于 Drizzle 查询优化）
export const stocksRelations = relations(stocks, ({ many }) => ({
  dailyData: many(stock_daily),
  favorites: many(user_stock_favorites),
}));

export const stockDailyRelations = relations(stock_daily, ({ one }) => ({
  stock: one(stocks, {
    fields: [stock_daily.ts_code],
    references: [stocks.ts_code],
  }),
}));

export const userStockFavoritesRelations = relations(user_stock_favorites, ({ one }) => ({
  user: one(user, {
    fields: [user_stock_favorites.user_id],
    references: [user.id],
  }),
  stock: one(stocks, {
    fields: [user_stock_favorites.ts_code],
    references: [stocks.ts_code],
  }),
}));
```

#### 连接池配置示例

```typescript
// apps/server/src/db/index.ts 更新
import { createClient } from "@libsql/client";
import { drizzle } from "drizzle-orm/libsql";
import * as schema from "./schema";

const client = createClient({
  url: process.env.DATABASE_URL || "file:local.db",
  authToken: process.env.DATABASE_AUTH_TOKEN,
  // 连接池配置
  maxConnections: 10,
  idleTimeout: 30000,
  acquireTimeout: 60000,
});

export const db = drizzle(client, { schema });

// 连接池错误处理和重试机制
client.on("error", (err) => {
  console.error("Database connection error:", err);
  // 实现重连逻辑
});
```

### 安全措施和访问控制

#### API 访问控制机制

1. **用户认证和授权**

   ```typescript
   // apps/server/src/routers/stocks.ts - 安全路由示例
   import { protectedProcedure } from "../trpc";
   import { z } from "zod";

   export const stockRouter = router({
     // 公开接口：股票基础查询 (限制查询频率)
     getStockList: publicProcedure
       .input(z.object({
         search: z.string().max(50).optional(),
         page: z.number().min(1).max(100).default(1),
         limit: z.number().min(1).max(50).default(20)
       }))
       .use(rateLimitMiddleware({ max: 100, windowMs: 60000 })) // 每分钟100次
       .query(async ({ input }) => { /* 实现 */ }),

     // 受保护接口：用户收藏管理
     addToFavorites: protectedProcedure
       .input(z.object({
         ts_code: z.string().regex(/^\d{6}\.(SH|SZ)$/) // 严格股票代码格式
       }))
       .use(userOwnershipValidation) // 验证用户只能操作自己的收藏
       .mutation(async ({ ctx, input }) => {
         // 验证用户身份
         if (!ctx.user?.id) throw new TRPCError({ code: "UNAUTHORIZED" });
         // 验证股票存在性
         const stock = await ctx.db.query.stocks.findFirst({
           where: eq(stocks.ts_code, input.ts_code)
         });
         if (!stock) throw new TRPCError({ 
           code: "NOT_FOUND", 
           message: "股票不存在或已退市" 
         });
         /* 执行收藏操作 */
       })
   });
   ```

2. **数据访问权限分离**

   ```typescript
   // 用户权限枚举
   enum StockPermission {
     READ_PUBLIC = "stock:read:public",     // 基础股票信息查询
     READ_DETAILED = "stock:read:detailed", // 详细交易数据查询
     MANAGE_FAVORITES = "stock:manage:favorites", // 收藏管理
     ADMIN_MANAGE = "stock:admin:manage"    // 管理员权限
   }

   // 权限验证中间件
   const requirePermission = (permission: StockPermission) => 
     middleware(async ({ ctx, next }) => {
       if (!hasPermission(ctx.user, permission)) {
         throw new TRPCError({ code: "FORBIDDEN" });
       }
       return next();
     });
   ```

3. **数据加密和脱敏**

   ```typescript
   // 敏感数据加密存储
   const encryptSensitiveData = (data: string): string => {
     const key = process.env.DATA_ENCRYPTION_KEY;
     return encrypt(data, key); // 使用 AES-256-GCM 加密
   };

   // 查询结果脱敏处理
   const sanitizeStockData = (data: StockData, userLevel: UserLevel) => {
     if (userLevel === "FREE") {
       // 免费用户：延迟数据，部分字段脱敏
       return {
         ...data,
         price: roundToDecimalPlaces(data.price, 1), // 价格精度降低
         volume: null, // 成交量对免费用户不可见
         timestamp: data.timestamp - 15 * 60 * 1000 // 15分钟延迟
       };
     }
     return data; // VIP用户获取完整实时数据
   };
   ```

#### 金融数据安全合规

1. **数据完整性保护**

   ```typescript
   // 股票数据完整性校验
   const validateStockData = (data: StockDailyData) => {
     const validations = [
       () => data.open > 0 && data.high > 0 && data.low > 0 && data.close > 0,
       () => data.high >= Math.max(data.open, data.close, data.low),
       () => data.low <= Math.min(data.open, data.close, data.high),
       () => data.volume >= 0 && data.amount >= 0,
       () => /^\d{8}$/.test(data.trade_date) // YYYYMMDD 格式
     ];
     
     const isValid = validations.every(fn => fn());
     if (!isValid) {
       throw new DataIntegrityError("股票数据完整性验证失败");
     }
   };

   // 数据变更审计日志
   const auditLog = {
     logDataChange: async (
       table: string, 
       operation: 'INSERT' | 'UPDATE' | 'DELETE',
       oldData: any, 
       newData: any, 
       userId: string
     ) => {
       await db.insert(audit_logs).values({
         table_name: table,
         operation,
         old_values: JSON.stringify(oldData),
         new_values: JSON.stringify(newData),
         user_id: userId,
         timestamp: Date.now(),
         ip_address: getClientIP(),
         user_agent: getUserAgent()
       });
     }
   };
   ```

2. **个人数据保护 (GDPR/网络安全法合规)**

   ```typescript
   // 用户数据加密存储
   export const user_data_encryption = {
     // 用户收藏记录加密
     encryptFavoritesList: (favorites: string[]) => {
       return encrypt(JSON.stringify(favorites), getUserEncryptionKey());
     },
     
     // 支持用户数据删除请求 (被遗忘权)
     deleteUserData: async (userId: string) => {
       await db.transaction(async (tx) => {
         // 删除用户收藏记录
         await tx.delete(user_stock_favorites).where(eq(user_stock_favorites.user_id, userId));
         // 匿名化审计日志中的用户信息
         await tx.update(audit_logs)
           .set({ user_id: "ANONYMIZED", ip_address: "ANONYMIZED" })
           .where(eq(audit_logs.user_id, userId));
         // 记录删除操作
         await auditLog.logDataChange("user_data", "DELETE", null, { userId }, "SYSTEM");
       });
     }
   };
   ```

3. **API 安全防护**

   ```typescript
   // SQL 注入防护 - 严格的输入验证
   const stockCodeValidator = z.string()
     .regex(/^[0-9]{6}\.(SH|SZ)$/, "无效的股票代码格式")
     .refine((code) => {
       // 额外的业务逻辑验证
       const market = code.split('.')[1];
       const number = code.split('.')[0];
       return (market === 'SH' && ['60', '68', '90'].includes(number.slice(0, 2))) ||
              (market === 'SZ' && ['00', '30', '20'].includes(number.slice(0, 2)));
     }, "无效的股票代码");

   // XSS 防护 - 输出编码
   const sanitizeOutput = (data: any) => {
     if (typeof data === 'string') {
       return data.replace(/[<>\"'&]/g, (char) => {
         const entities = { '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '&': '&amp;' };
         return entities[char as keyof typeof entities];
       });
     }
     return data;
   };

   // DoS 防护 - 资源限制
   const resourceLimiter = {
     maxQueryRows: 1000,        // 单次查询最大行数
     maxConcurrentQueries: 10,  // 单用户并发查询限制
     queryTimeout: 30000,       // 查询超时 30秒
     
     enforceLimit: async (userId: string, query: string) => {
       const activeQueries = await getActiveQueries(userId);
       if (activeQueries.length >= this.maxConcurrentQueries) {
         throw new TRPCError({ 
           code: "TOO_MANY_REQUESTS", 
           message: "并发查询数量超限" 
         });
       }
     }
   };
   ```

### 错误处理和边缘情况

#### 数据库连接异常处理

1. **连接超时处理**
   - 连接超时 (>60s): 自动重试 3 次，间隔递增 (1s, 3s, 9s)
   - 重试失败: 切换到只读模式，返回缓存数据
   - 健康检查: 每 30 秒检测连接状态，恢复后自动切回读写模式

2. **并发冲突处理**
   ```typescript
   // 乐观锁处理并发更新
   try {
     await db.transaction(async (tx) => {
       const stock = await tx
         .select()
         .from(stocks)
         .where(eq(stocks.ts_code, code));
       if (!stock.length) throw new Error("Stock not found");
       // 检查版本号避免并发修改
       await tx.update(stocks).set({ ...updates, updated_at: Date.now() });
     });
   } catch (error) {
     if (error.code === "SQLITE_BUSY") {
       // 重试逻辑，最多 3 次
       await new Promise((resolve) => setTimeout(resolve, Math.random() * 100));
       // 重试操作...
     }
   }
   ```

#### 数据完整性异常处理

1. **外键约束违反**
   - 收藏不存在的股票: 返回友好错误 "股票不存在或已退市"
   - 删除被收藏的股票: 先删除收藏关系，再删除股票记录
2. **数据类型异常**
   - 股价为负值: 数据验证拒绝，记录异常日志
   - 日期格式错误: 自动格式化修复，无法修复则跳过该记录
3. **大数据量操作异常**
   - 批量导入中断: 回滚已导入数据，记录中断位置，支持断点续传
   - 内存不足: 减小批处理大小，从 1000 条降至 100 条

#### API 层面错误处理

1. **查询超时处理**

   ```typescript
   const timeout = new Promise((_, reject) =>
     setTimeout(() => reject(new Error("Query timeout")), 5000)
   );

   try {
     const result = await Promise.race([dbQuery, timeout]);
     return result;
   } catch (error) {
     if (error.message === "Query timeout") {
       // 返回缓存数据或降级响应
       return getCachedStockData(ts_code);
     }
     throw error;
   }
   ```

2. **恶意输入防护**
   - SQL 注入防护: 使用 Drizzle ORM 参数化查询
   - 输入长度限制: 股票代码最大 12 字符，名称最大 50 字符
   - 特殊字符过滤: 禁止输入控制字符和 SQL 关键词

#### 迁移过程错误处理

1. **迁移失败回滚**
   - 自动检测迁移失败 (schema 不匹配)
   - 3 次失败后触发自动回滚到上一个稳定版本
   - 发送告警通知管理员介入

2. **数据丢失保护**
   - 迁移前强制创建数据快照
   - 迁移过程实时数据校验
   - 发现数据不一致立即暂停迁移

#### 极端场景和边缘情况处理

1. **磁盘空间不足处理**

   ```typescript
   // apps/server/src/lib/disk-monitoring.ts
   import { promises as fs } from "fs";
   
   export class DiskSpaceMonitor {
     private readonly thresholds = {
       warning: 0.8,      // 80%使用率警告
       critical: 0.9,     // 90%使用率紧急
       emergency: 0.95    // 95%使用率紧急停止
     };

     async checkDiskSpace(): Promise<DiskSpaceStatus> {
       const stats = await fs.statvfs(process.cwd());
       const total = stats.f_blocks * stats.f_frsize;
       const free = stats.f_available * stats.f_frsize;
       const used = total - free;
       const usageRatio = used / total;

       if (usageRatio >= this.thresholds.emergency) {
         // 紧急情况：停止写入操作，启用只读模式
         await this.enableReadOnlyMode();
         await this.sendEmergencyAlert("磁盘空间严重不足，已启用只读模式");
         return { status: "emergency", usage: usageRatio };
       }

       if (usageRatio >= this.thresholds.critical) {
         // 关键警告：执行紧急清理
         await this.performEmergencyCleanup();
         await this.sendCriticalAlert("磁盘空间不足，正在执行紧急清理");
         return { status: "critical", usage: usageRatio };
       }

       if (usageRatio >= this.thresholds.warning) {
         // 警告：执行常规清理
         await this.performRoutineCleanup();
         return { status: "warning", usage: usageRatio };
       }

       return { status: "normal", usage: usageRatio };
     }

     private async performEmergencyCleanup() {
       // 1. 清理临时文件
       await this.cleanTempFiles();
       
       // 2. 压缩旧的WAL文件
       await this.compressOldWalFiles();
       
       // 3. 删除过期的备份文件（保留最近7天）
       await this.cleanOldBackups(7);
       
       // 4. 清理应用日志（保留最近3天）
       await this.cleanApplicationLogs(3);
       
       // 5. 执行数据库VACUUM操作释放空间
       await this.vacuumDatabase();
     }

     private async enableReadOnlyMode() {
       // 设置全局只读标志
       process.env.DATABASE_READONLY = "true";
       
       // 更新连接池配置为只读
       await this.updateConnectionPoolToReadOnly();
       
       // 拒绝所有写入操作
       await this.blockWriteOperations();
     }
   }
   ```

2. **极端并发场景处理**

   ```typescript
   // apps/server/src/lib/concurrency-control.ts
   export class ConcurrencyController {
     private activeConnections = new Map<string, number>();
     private requestQueue = new Map<string, Request[]>();
     private readonly limits = {
       maxGlobalConnections: 100,      // 全局最大连接数
       maxUserConnections: 10,         // 单用户最大连接数
       maxQueueSize: 50,              // 最大队列长度
       queueTimeoutMs: 30000          // 队列超时时间
     };

     async acquireConnection(userId: string): Promise<Connection> {
       // 检查全局连接数限制
       const totalConnections = Array.from(this.activeConnections.values())
         .reduce((sum, count) => sum + count, 0);
       
       if (totalConnections >= this.limits.maxGlobalConnections) {
         throw new ServiceUnavailableError("系统繁忙，请稍后重试");
       }

       // 检查单用户连接数限制
       const userConnections = this.activeConnections.get(userId) || 0;
       if (userConnections >= this.limits.maxUserConnections) {
         // 将请求加入队列
         return this.enqueueRequest(userId);
       }

       // 分配连接
       this.activeConnections.set(userId, userConnections + 1);
       return this.createConnection(userId);
     }

     private async enqueueRequest(userId: string): Promise<Connection> {
       const queue = this.requestQueue.get(userId) || [];
       
       if (queue.length >= this.limits.maxQueueSize) {
         throw new TooManyRequestsError("请求队列已满，请稍后重试");
       }

       return new Promise((resolve, reject) => {
         const request = {
           userId,
           resolve,
           reject,
           timestamp: Date.now()
         };

         queue.push(request);
         this.requestQueue.set(userId, queue);

         // 设置超时
         setTimeout(() => {
           this.removeFromQueue(userId, request);
           reject(new TimeoutError("请求等待超时"));
         }, this.limits.queueTimeoutMs);
       });
     }

     async releaseConnection(userId: string) {
       const current = this.activeConnections.get(userId) || 0;
       const newCount = Math.max(0, current - 1);
       this.activeConnections.set(userId, newCount);

       // 处理队列中的下一个请求
       await this.processNextInQueue(userId);
     }

     // 熔断器模式：服务降级
     private circuitBreaker = {
       failures: 0,
       lastFailureTime: 0,
       state: "CLOSED" as "CLOSED" | "OPEN" | "HALF_OPEN",
       
       async execute<T>(operation: () => Promise<T>): Promise<T> {
         if (this.state === "OPEN") {
           // 检查是否可以尝试恢复
           if (Date.now() - this.lastFailureTime > 60000) { // 1分钟后尝试恢复
             this.state = "HALF_OPEN";
           } else {
             throw new ServiceDegradedError("服务暂时不可用，已启用降级模式");
           }
         }

         try {
           const result = await operation();
           
           if (this.state === "HALF_OPEN") {
             this.state = "CLOSED";
             this.failures = 0;
           }
           
           return result;
         } catch (error) {
           this.failures++;
           this.lastFailureTime = Date.now();
           
           if (this.failures >= 5) { // 5次失败后开启熔断
             this.state = "OPEN";
           }
           
           throw error;
         }
       }
     };
   }
   ```

3. **数据损坏检测和修复机制**

   ```typescript
   // apps/server/src/lib/data-integrity.ts
   export class DataIntegrityManager {
     async performHealthCheck(): Promise<HealthCheckResult> {
       const checks = await Promise.allSettled([
         this.checkDatabaseConnectivity(),
         this.checkSchemaIntegrity(), 
         this.checkDataConsistency(),
         this.checkForeignKeyConstraints(),
         this.checkIndexHealth(),
         this.checkCorruptedData()
       ]);

       const results = checks.map((check, index) => ({
         name: ['connectivity', 'schema', 'data', 'foreign_keys', 'indexes', 'corruption'][index],
         status: check.status === 'fulfilled' ? 'passed' : 'failed',
         details: check.status === 'fulfilled' ? check.value : check.reason?.message
       }));

       const failedChecks = results.filter(r => r.status === 'failed');
       
       if (failedChecks.length > 0) {
         await this.handleHealthCheckFailures(failedChecks);
       }

       return {
         overall: failedChecks.length === 0 ? 'healthy' : 'unhealthy',
         checks: results,
         timestamp: Date.now()
       };
     }

     private async checkCorruptedData(): Promise<void> {
       // 检查股票价格数据异常
       const suspiciousData = await db
         .select()
         .from(stock_daily)
         .where(
           or(
             lt(stock_daily.open, 0),           // 负价格
             lt(stock_daily.high, stock_daily.low), // 最高价低于最低价
             lt(stock_daily.vol, 0),           // 负成交量
             // 价格波动超过±20%（异常波动检测）
             gt(
               sql`ABS(${stock_daily.close} - ${stock_daily.open}) / ${stock_daily.open}`,
               0.2
             )
           )
         )
         .limit(100);

       if (suspiciousData.length > 0) {
         await this.quarantineCorruptedData(suspiciousData);
         throw new DataCorruptionError(`发现 ${suspiciousData.length} 条异常数据记录`);
       }
     }

     private async quarantineCorruptedData(corruptedRecords: any[]) {
       // 将损坏的数据移动到隔离表
       await db.insert(corrupted_data_quarantine).values(
         corruptedRecords.map(record => ({
           table_name: 'stock_daily',
           record_id: record.id.toString(),
           corrupted_data: JSON.stringify(record),
           quarantine_reason: 'data_integrity_violation',
           quarantine_time: Date.now()
         }))
       );

       // 从原表中删除损坏的数据
       const corruptedIds = corruptedRecords.map(r => r.id);
       await db.delete(stock_daily).where(inArray(stock_daily.id, corruptedIds));
       
       // 发送告警
       await this.sendDataCorruptionAlert(corruptedRecords);
     }

     // 自动数据修复
     async attemptDataRepair(): Promise<RepairResult> {
       const repairActions = [
         this.repairMissingIndices(),
         this.repairForeignKeyViolations(),
         this.repairDuplicateRecords(),
         this.repairInconsistentTimestamps()
       ];

       const results = await Promise.allSettled(repairActions);
       
       return {
         successful: results.filter(r => r.status === 'fulfilled').length,
         failed: results.filter(r => r.status === 'rejected').length,
         details: results
       };
     }

     private async repairDuplicateRecords() {
       // 查找重复的股票数据记录
       const duplicates = await db
         .select({
           ts_code: stock_daily.ts_code,
           trade_date: stock_daily.trade_date,
           count: count()
         })
         .from(stock_daily)
         .groupBy(stock_daily.ts_code, stock_daily.trade_date)
         .having(gt(count(), 1));

       for (const dup of duplicates) {
         // 保留最新的记录，删除旧记录
         const records = await db
           .select()
           .from(stock_daily)
           .where(
             and(
               eq(stock_daily.ts_code, dup.ts_code),
               eq(stock_daily.trade_date, dup.trade_date)
             )
           )
           .orderBy(desc(stock_daily.created_at));

         // 删除除最新记录外的所有重复记录
         const toDelete = records.slice(1);
         if (toDelete.length > 0) {
           const deleteIds = toDelete.map(r => r.id);
           await db.delete(stock_daily).where(inArray(stock_daily.id, deleteIds));
         }
       }
     }
   }
   ```

4. **网络分区和服务中断处理**

   ```typescript
   // apps/server/src/lib/resilience.ts
   export class ResilienceManager {
     private isOnline = true;
     private cachedData = new Map<string, { data: any; expiry: number }>();
     
     async handleNetworkPartition() {
       this.isOnline = false;
       
       // 启用离线模式
       await this.enableOfflineMode();
       
       // 定期检查网络连接恢复
       const recoveryCheck = setInterval(async () => {
         if (await this.checkNetworkConnectivity()) {
           this.isOnline = true;
           clearInterval(recoveryCheck);
           await this.handleNetworkRecovery();
         }
       }, 30000); // 每30秒检查一次
     }

     private async enableOfflineMode() {
       // 1. 停止所有对外部服务的调用
       await this.pauseExternalServiceCalls();
       
       // 2. 启用本地缓存数据服务
       await this.enableCacheService();
       
       // 3. 记录所有离线期间的写入操作
       await this.enableOfflineWriteLog();
       
       // 4. 通知用户系统正在离线模式运行
       await this.notifyOfflineMode();
     }

     private async handleNetworkRecovery() {
       // 1. 同步离线期间的写入操作
       await this.syncOfflineWrites();
       
       // 2. 重新启用外部服务调用
       await this.resumeExternalServiceCalls();
       
       // 3. 刷新缓存数据
       await this.refreshCachedData();
       
       // 4. 执行完整性检查
       await this.performRecoveryIntegrityCheck();
       
       // 5. 通知系统已恢复正常
       await this.notifyOnlineMode();
     }

     // 缓存回退策略
     async getDataWithFallback<T>(
       key: string, 
       primarySource: () => Promise<T>, 
       cacheExpiryMs: number = 300000 // 5分钟
     ): Promise<T> {
       if (this.isOnline) {
         try {
           const data = await primarySource();
           // 更新缓存
           this.cachedData.set(key, {
             data,
             expiry: Date.now() + cacheExpiryMs
           });
           return data;
         } catch (error) {
           // 主数据源失败，尝试使用缓存
           console.warn(`Primary source failed for ${key}, falling back to cache`);
         }
       }

       // 尝试从缓存获取数据
       const cached = this.cachedData.get(key);
       if (cached && cached.expiry > Date.now()) {
         return cached.data;
       }

       // 如果缓存也没有，返回默认值或抛出错误
       throw new DataUnavailableError(`数据暂时不可用: ${key}`);
     }
   }
   ```

### SLA监控和告警系统

#### 系统级别SLA定义

1. **可用性SLA**

   ```typescript
   // apps/server/src/lib/sla-monitoring.ts
   export const SLADefinitions = {
     availability: {
       target: 99.9,                    // 99.9%可用性目标
       measurement_window: "monthly",   // 月度测量窗口
       downtime_threshold: 43.8,        // 月度最大停机时间(分钟)
       critical_threshold: 99.5,        // 关键警告阈值
       emergency_threshold: 99.0        // 紧急处理阈值
     },
     
     performance: {
       api_response_time: {
         target: 200,                   // 目标响应时间 200ms
         p95_threshold: 500,            // 95分位数阈值 500ms
         p99_threshold: 1000,           // 99分位数阈值 1000ms
         measurement_interval: 60       // 测量间隔 60秒
       },
       
       database_query: {
         avg_response: 100,             // 平均查询时间 100ms
         slow_query_threshold: 500,     // 慢查询阈值 500ms
         max_concurrent_queries: 100,   // 最大并发查询数
         connection_pool_util: 80       // 连接池使用率阈值 80%
       },
       
       throughput: {
         requests_per_second: 1000,     // 目标RPS
         peak_capacity: 2000,           // 峰值容量
         sustained_load: 500,           // 持续负载能力
         burst_duration: 300            // 突发负载持续时间(秒)
       }
     },
     
     business_metrics: {
       data_freshness: {
         stock_data_delay: 300,         // 股票数据最大延迟 5分钟
         user_action_sync: 30,          // 用户操作同步时间 30秒
         cache_invalidation: 60         // 缓存失效时间 60秒
       },
       
       data_quality: {
         completeness_rate: 99.5,       // 数据完整度 99.5%
         accuracy_rate: 99.9,           // 数据准确度 99.9%
         consistency_check_pass: 100,   // 一致性检查通过率 100%
         anomaly_detection_rate: 95     // 异常检测覆盖率 95%
       }
     }
   };

   export class SLAMonitor {
     private metrics = new Map<string, MetricHistory>();
     private alerts = new AlertManager();

     async collectMetrics() {
       const timestamp = Date.now();
       
       // 收集系统指标
       const systemMetrics = await this.collectSystemMetrics();
       const businessMetrics = await this.collectBusinessMetrics();
       const performanceMetrics = await this.collectPerformanceMetrics();

       // 评估SLA合规性
       const slaStatus = await this.evaluateSLA({
         ...systemMetrics,
         ...businessMetrics,
         ...performanceMetrics
       });

       // 触发告警
       if (!slaStatus.compliant) {
         await this.handleSLAViolation(slaStatus);
       }

       // 存储历史数据
       await this.storeMetrics(timestamp, slaStatus);
     }

     private async collectSystemMetrics() {
       return {
         uptime: process.uptime(),
         memory_usage: process.memoryUsage().heapUsed / 1024 / 1024, // MB
         cpu_usage: await this.getCPUUsage(),
         disk_usage: await this.getDiskUsage(),
         active_connections: await this.getActiveConnections(),
         request_rate: await this.getRequestRate()
       };
     }

     private async collectBusinessMetrics() {
       const stockCount = await db.select({ count: count() }).from(stocks);
       const dailyDataCount = await db.select({ count: count() }).from(stock_daily);
       const favoriteCount = await db.select({ count: count() }).from(user_stock_favorites);

       return {
         total_stocks: stockCount[0].count,
         total_daily_records: dailyDataCount[0].count,
         total_favorites: favoriteCount[0].count,
         data_freshness: await this.checkDataFreshness(),
         data_completeness: await this.checkDataCompleteness()
       };
     }

     private async evaluateSLA(metrics: any): Promise<SLAStatus> {
       const violations = [];

       // 检查响应时间SLA
       if (metrics.avg_response_time > SLADefinitions.performance.api_response_time.target) {
         violations.push({
           type: 'performance',
           metric: 'response_time',
           actual: metrics.avg_response_time,
           target: SLADefinitions.performance.api_response_time.target,
           severity: metrics.avg_response_time > 1000 ? 'critical' : 'warning'
         });
       }

       // 检查可用性SLA
       const uptime_percentage = (metrics.uptime / (30 * 24 * 60 * 60)) * 100; // 月度可用性
       if (uptime_percentage < SLADefinitions.availability.target) {
         violations.push({
           type: 'availability',
           metric: 'uptime',
           actual: uptime_percentage,
           target: SLADefinitions.availability.target,
           severity: 'critical'
         });
       }

       // 检查数据质量SLA
       if (metrics.data_completeness < SLADefinitions.business_metrics.data_quality.completeness_rate) {
         violations.push({
           type: 'data_quality',
           metric: 'completeness',
           actual: metrics.data_completeness,
           target: SLADefinitions.business_metrics.data_quality.completeness_rate,
           severity: 'warning'
         });
       }

       return {
         compliant: violations.length === 0,
         violations,
         overall_score: this.calculateOverallScore(metrics),
         timestamp: Date.now()
       };
     }
   }
   ```

2. **监控指标收集和分析**

   ```typescript
   // apps/server/src/lib/metrics-collector.ts
   export class MetricsCollector {
     private prometheus = new PrometheusMetrics();
     
     // 核心性能指标
     private readonly coreMetrics = {
       // HTTP请求指标
       http_requests_total: this.prometheus.counter({
         name: 'neostock_http_requests_total',
         help: 'Total HTTP requests',
         labelNames: ['method', 'route', 'status_code']
       }),
       
       http_request_duration: this.prometheus.histogram({
         name: 'neostock_http_request_duration_seconds',
         help: 'HTTP request duration in seconds',
         labelNames: ['method', 'route'],
         buckets: [0.1, 0.2, 0.5, 1, 2, 5, 10]
       }),

       // 数据库指标
       db_connections_active: this.prometheus.gauge({
         name: 'neostock_db_connections_active',
         help: 'Active database connections'
       }),
       
       db_query_duration: this.prometheus.histogram({
         name: 'neostock_db_query_duration_seconds',
         help: 'Database query duration in seconds',
         labelNames: ['operation', 'table'],
         buckets: [0.01, 0.05, 0.1, 0.2, 0.5, 1, 2]
       }),

       // 业务指标
       stocks_processed_total: this.prometheus.counter({
         name: 'neostock_stocks_processed_total',
         help: 'Total number of stocks processed',
         labelNames: ['operation'] // insert, update, delete
       }),
       
       user_actions_total: this.prometheus.counter({
         name: 'neostock_user_actions_total',
         help: 'Total user actions',
         labelNames: ['action', 'user_type'] // favorite, search, view
       }),

       // 系统资源指标
       memory_usage_bytes: this.prometheus.gauge({
         name: 'neostock_memory_usage_bytes',
         help: 'Memory usage in bytes'
       }),
       
       disk_usage_ratio: this.prometheus.gauge({
         name: 'neostock_disk_usage_ratio',
         help: 'Disk usage ratio (0-1)'
       })
     };

     // 自动指标收集
     startCollection() {
       // 每分钟收集系统指标
       setInterval(() => {
         this.collectSystemMetrics();
       }, 60000);

       // 每5分钟收集业务指标
       setInterval(() => {
         this.collectBusinessMetrics();
       }, 300000);

       // 每30秒收集性能指标
       setInterval(() => {
         this.collectPerformanceMetrics();
       }, 30000);
     }

     private async collectSystemMetrics() {
       const memUsage = process.memoryUsage();
       this.coreMetrics.memory_usage_bytes.set(memUsage.heapUsed);

       const diskUsage = await this.getDiskUsage();
       this.coreMetrics.disk_usage_ratio.set(diskUsage.used / diskUsage.total);
     }

     private async collectBusinessMetrics() {
       // 收集股票相关业务指标
       const stockMetrics = await this.getStockMetrics();
       this.coreMetrics.stocks_processed_total.inc(
         { operation: 'update' },
         stockMetrics.updated_count
       );

       // 收集用户行为指标
       const userMetrics = await this.getUserActionMetrics();
       Object.entries(userMetrics).forEach(([action, count]) => {
         this.coreMetrics.user_actions_total.inc(
           { action, user_type: 'regular' },
           count as number
         );
       });
     }
   }
   ```

3. **异常检测和预警系统**

   ```typescript
   // apps/server/src/lib/anomaly-detection.ts
   export class AnomalyDetector {
     private readonly thresholds = {
       response_time: {
         moving_average_window: 300,     // 5分钟移动平均
         deviation_multiplier: 2.5,      // 标准差倍数
         spike_threshold: 3.0           // 突增阈值倍数
       },
       
       error_rate: {
         baseline_window: 3600,          // 1小时基线窗口
         alert_threshold: 0.05,          // 5%错误率告警
         critical_threshold: 0.10        // 10%错误率紧急
       },
       
       user_activity: {
         daily_pattern_window: 7,        // 7天模式窗口
         anomaly_score_threshold: 0.8,   // 异常评分阈值
         sudden_drop_threshold: 0.3      // 突降30%阈值
       },
       
       data_quality: {
         completeness_threshold: 0.95,   // 完整度阈值95%
         freshness_threshold: 300,       // 数据新鲜度5分钟
         consistency_threshold: 0.99     // 一致性阈值99%
       }
     };

     async detectAnomalies(): Promise<AnomalyReport> {
       const anomalies = [];

       // 检测性能异常
       const performanceAnomalies = await this.detectPerformanceAnomalies();
       anomalies.push(...performanceAnomalies);

       // 检测业务指标异常
       const businessAnomalies = await this.detectBusinessAnomalies();
       anomalies.push(...businessAnomalies);

       // 检测数据质量异常
       const dataQualityAnomalies = await this.detectDataQualityAnomalies();
       anomalies.push(...dataQualityAnomalies);

       // 生成异常报告
       return {
         timestamp: Date.now(),
         total_anomalies: anomalies.length,
         anomalies,
         severity_distribution: this.analyzeSeverity(anomalies),
         recommended_actions: this.generateRecommendations(anomalies)
       };
     }

     private async detectPerformanceAnomalies(): Promise<Anomaly[]> {
       const anomalies = [];
       
       // 响应时间异常检测
       const responseTimeData = await this.getRecentResponseTimes();
       const avgResponseTime = responseTimeData.reduce((sum, rt) => sum + rt, 0) / responseTimeData.length;
       const stdDev = this.calculateStandardDeviation(responseTimeData, avgResponseTime);
       
       const currentResponseTime = responseTimeData[responseTimeData.length - 1];
       if (currentResponseTime > avgResponseTime + (stdDev * this.thresholds.response_time.deviation_multiplier)) {
         anomalies.push({
           type: 'performance',
           metric: 'response_time',
           severity: currentResponseTime > 1000 ? 'critical' : 'warning',
           actual_value: currentResponseTime,
           expected_range: [avgResponseTime - stdDev, avgResponseTime + stdDev],
           description: `响应时间异常: ${currentResponseTime}ms (正常范围: ${Math.round(avgResponseTime)}±${Math.round(stdDev)}ms)`,
           suggested_action: '检查数据库性能和连接池状态'
         });
       }

       // 错误率异常检测
       const errorRate = await this.getCurrentErrorRate();
       if (errorRate > this.thresholds.error_rate.alert_threshold) {
         anomalies.push({
           type: 'error_rate',
           metric: 'http_errors',
           severity: errorRate > this.thresholds.error_rate.critical_threshold ? 'critical' : 'warning',
           actual_value: errorRate,
           expected_range: [0, this.thresholds.error_rate.alert_threshold],
           description: `错误率异常: ${(errorRate * 100).toFixed(2)}%`,
           suggested_action: '检查应用日志，排查错误原因'
         });
       }

       return anomalies;
     }

     private async detectBusinessAnomalies(): Promise<Anomaly[]> {
       const anomalies = [];

       // 用户活跃度异常
       const currentUserActivity = await this.getCurrentUserActivity();
       const historicalAverage = await this.getHistoricalUserActivityAverage();
       
       if (currentUserActivity < historicalAverage * this.thresholds.user_activity.sudden_drop_threshold) {
         anomalies.push({
           type: 'business',
           metric: 'user_activity',
           severity: 'warning',
           actual_value: currentUserActivity,
           expected_range: [historicalAverage * 0.7, historicalAverage * 1.3],
           description: `用户活跃度异常下降: 当前${currentUserActivity}，历史平均${historicalAverage}`,
           suggested_action: '检查服务可用性和用户体验问题'
         });
       }

       // 股票数据更新异常
       const lastDataUpdate = await this.getLastStockDataUpdate();
       const timeSinceUpdate = Date.now() - lastDataUpdate;
       
       if (timeSinceUpdate > this.thresholds.data_quality.freshness_threshold * 1000) {
         anomalies.push({
           type: 'data_quality',
           metric: 'data_freshness',
           severity: 'critical',
           actual_value: timeSinceUpdate / 1000,
           expected_range: [0, this.thresholds.data_quality.freshness_threshold],
           description: `股票数据更新延迟: ${Math.round(timeSinceUpdate / 1000)}秒`,
           suggested_action: '检查数据源连接和同步任务状态'
         });
       }

       return anomalies;
     }
   }
   ```

4. **告警和通知系统**

   ```typescript
   // apps/server/src/lib/alert-manager.ts
   export class AlertManager {
     private readonly alertChannels = {
       slack: new SlackNotifier(process.env.SLACK_WEBHOOK_URL),
       email: new EmailNotifier(process.env.SMTP_CONFIG),
       sms: new SMSNotifier(process.env.SMS_CONFIG),
       webhook: new WebhookNotifier(process.env.ALERT_WEBHOOK_URL)
     };

     private readonly escalationRules = {
       warning: {
         immediate: ['slack'],
         after_5min: ['email'],
         after_15min: ['sms']
       },
       critical: {
         immediate: ['slack', 'sms'],
         after_2min: ['email'],
         after_10min: ['webhook'] // 触发自动恢复流程
       },
       emergency: {
         immediate: ['slack', 'sms', 'email', 'webhook'],
         after_1min: ['escalate_to_oncall']
       }
     };

     async sendAlert(alert: Alert) {
       const escalationPlan = this.escalationRules[alert.severity];
       
       // 立即发送告警
       for (const channel of escalationPlan.immediate) {
         await this.sendToChannel(channel, alert);
       }

       // 设置升级告警
       this.scheduleEscalation(alert, escalationPlan);
       
       // 记录告警历史
       await this.recordAlert(alert);
     }

     private async sendToChannel(channel: string, alert: Alert) {
       const formatter = new AlertFormatter();
       const message = formatter.format(alert, channel);
       
       try {
         await this.alertChannels[channel].send(message);
         console.log(`Alert sent to ${channel}: ${alert.id}`);
       } catch (error) {
         console.error(`Failed to send alert to ${channel}:`, error);
         // 尝试备用通道
         await this.sendToBackupChannel(alert);
       }
     }

     private generateAlertMessage(alert: Alert): string {
       return `
🚨 【${alert.severity.toUpperCase()}】系统告警

📊 **指标**: ${alert.metric}
📈 **当前值**: ${alert.actual_value}
🎯 **目标值**: ${alert.target_value}
⏰ **发生时间**: ${new Date(alert.timestamp).toLocaleString('zh-CN')}
📍 **影响范围**: ${alert.affected_services?.join(', ') || '系统全局'}

💡 **建议措施**: ${alert.suggested_action}
🔗 **监控面板**: ${this.generateDashboardUrl(alert.metric)}
       `.trim();
     }
   }
   ```

## Testing

### 测试框架和标准

**测试技术栈**：

- **后端测试**: Bun:test + Vitest
- **数据库测试**: 内存数据库 (`:memory:`) 进行快速测试
- **覆盖率要求**: 数据库操作 >90%，总体覆盖率 >80%
- **测试工具**: @vitest/coverage-v8

### 测试文件位置

基于测试策略 [Source: docs/testing-strategy.md]：

- **数据库测试**: `apps/server/src/__tests__/db/`
- **API测试**: `apps/server/src/__tests__/routers/`
- **集成测试**: `apps/server/src/__tests__/integration/`

### 核心测试要求

#### 1. Schema 测试

**测试文件**: `apps/server/src/__tests__/db/schema/stocks.test.ts`

- 验证新表结构定义正确性
- 测试外键约束和索引有效性
- 验证数据类型和长度限制
- **Mock 数据规格**:
  - 股票基础数据: 最少 100 条 A 股样本数据，覆盖不同行业和市场类型
  - 日线数据: 每个测试股票至少包含 30 天历史数据
  - 用户收藏: 模拟 10 个用户各收藏 5-20 只股票的测试场景

#### 2. 迁移测试

**测试文件**: `apps/server/src/__tests__/db/migrations/002_v1.1_stocks.test.ts`

- 测试 up 迁移成功创建新表
- 测试 down 迁移正确回滚
- 验证迁移事务管理和原子性
- 测试迁移状态跟踪和日志记录
- **扩展测试场景**:
  - 模拟迁移中断场景 (网络断开、系统重启)
  - 测试并发迁移冲突处理
  - 验证大数据量迁移性能 (1万条股票 + 100万条日线数据)

#### 3. 性能测试

**测试文件**: `apps/server/src/__tests__/performance/database.test.ts`

- 验证百人级并发访问性能
- 测试单次查询响应时间 <200ms
- 验证连接池管理有效性
- 测试种子数据导入性能 <5分钟
- **具体测试场景**:
  - 100 并发用户同时查询不同股票信息
  - 复杂条件搜索测试 (行业 + 关键词 + 日期范围)
  - 收藏股票列表聚合查询性能测试
  - 历史数据时间序列查询性能验证

#### 4. 兼容性测试

**测试文件**: `apps/server/src/__tests__/integration/compatibility.test.ts`

- 验证现有认证功能不受影响
- 测试数据迁移零停机升级
- 验证现有用户数据完整性
- **边缘情况测试**:
  - 现有用户登录后立即使用新功能
  - 迁移过程中的用户会话保持
  - 新旧 schema 版本并存兼容性

#### 5. API 集成测试

**测试文件**: `apps/server/src/__tests__/routers/stocks.test.ts`

- 测试新 API 端点与 tRPC 路由体系兼容性
- 验证端到端类型安全
- 测试用户权限控制
- **端到端测试场景**:
  - 用户注册 → 登录 → 搜索股票 → 添加收藏 → 查看收藏列表
  - 股票数据更新 → 用户查询最新数据 → 数据一致性验证
  - API 错误处理 → 前端友好错误提示 → 用户体验验证

### 测试数据管理

#### Mock 数据生成

```typescript
// apps/server/src/__tests__/helpers/mock-stock-data.ts
export const generateMockStocks = (count: number) => {
  // 生成包含不同行业、市场类型的测试股票数据
};

export const generateMockDailyData = (stockCode: string, days: number) => {
  // 生成指定股票的历史交易数据
};
```

#### 测试环境配置

- 使用独立的测试数据库实例
- 每个测试套件前后自动清理数据
- 并行测试隔离，避免数据冲突

### 质量门控集成

**必须通过的测试检查**：

- 所有单元测试通过率 100%
- 代码覆盖率 >90% (数据库层)
- 性能测试达标 (查询<200ms, 并发支持100用户)
- 兼容性测试零失败
- Mock数据完整性验证通过

## Change Log

| Date       | Version | Description  | Author             |
| ---------- | ------- | ------------ | ------------------ |
| 2025-08-25 | 1.0     | 初始故事创建 | Bob (Scrum Master) |
| 2025-08-25 | 1.1     | 基于 PO 验证反馈的关键修复：1)添加独立 Testing 章节 2)完善外键约束技术细节 3)明确任务依赖关系 4)增加连接池配置验证依据 | Sarah (Product Owner) |
| 2025-08-25 | 1.2     | 模板合规性修复：完善Dev Agent Record和QA Results章节结构，添加任务跟踪清单 | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used

_待开发代理填写使用的具体AI模型名称和版本_

### Debug Log References

_待开发代理填写实施过程中生成的调试日志或追踪记录_

### Completion Notes List

- [ ] Task 1: 数据库表结构设计
- [ ] Task 2: SQLite架构优化
- [ ] Task 3: 迁移系统增强
- [ ] Task 4: 兼容性保证
- [ ] Task 5: 数据存储优化
- [ ] Task 6: 监控系统建立

### File List

_待开发代理记录实施过程中创建、修改或影响的所有文件_

## QA Results

_待QA代理完成故事实施的QA审查结果_

### 功能验收测试结果

- [ ] 所有验收标准通过验证
- [ ] 性能要求达标验证
- [ ] 兼容性测试通过

### 质量门控检查结果

- [ ] 代码覆盖率 >90% (数据库层)
- [ ] 所有单元测试通过
- [ ] 性能测试达标
- [ ] 安全扫描通过
